<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>python中re模块使用，正则表达式</title>
      <link href="/2018/05/21/python%E4%B8%ADre%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/05/21/python%E4%B8%ADre%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正则表达式的基础知识就不说了,有兴趣的可以点击这里，提取一般分两种情况，一种是提取在文本中提取单个位置的字符串，另一种是提取连续多个位置的字符串。日志分析会遇到这种情况，下面我会分别讲一下对应的方法。</p><h2 id="一、单个位置的字符串提取"><a href="#一、单个位置的字符串提取" class="headerlink" title="一、单个位置的字符串提取"></a>一、单个位置的字符串提取</h2><p>这种情况我们可以使用(.+?)这个正则表达式来提取。 举例，一个字符串”a123b”,如果我们想提取ab之间的值123，可以使用findall配合正则表达式，这样会返回一个包含所以符合情况的list。</p><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str = <span class="string">"a123b"</span></span><br><span class="line"><span class="keyword">print</span> re.findall(<span class="string">r"a(.+?)b"</span>,str)<span class="comment">#</span></span><br><span class="line">输出[<span class="string">'123'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="1-1贪婪和非贪婪匹配"><a href="#1-1贪婪和非贪婪匹配" class="headerlink" title="1.1贪婪和非贪婪匹配"></a>1.1贪婪和非贪婪匹配</h3><p>如果我们有一个字符串”a123b456b”，如果我们想匹配a和最后一个b之间的所有值而非a和第一个出现的b之间的值，可以用?来控制正则贪婪和非贪婪匹配的情况。</p><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str = <span class="string">"a123b456b"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> re.findall(<span class="string">r"a(.+?)b"</span>, str)</span><br><span class="line"><span class="comment">#输出['123']#?控制只匹配0或1个,所以只会输出和最近的b之间的匹配情况</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> re.findall(<span class="string">r"a(.+)b"</span>, str)</span><br><span class="line"><span class="comment">#输出['123b456']</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> re.findall(<span class="string">r"a(.*)b"</span>, str)</span><br><span class="line"><span class="comment">#输出['123b456']</span></span><br></pre></td></tr></table></figure></p><h3 id="1-2多行匹配"><a href="#1-2多行匹配" class="headerlink" title="1.2多行匹配"></a>1.2多行匹配</h3><p>如果你要多行匹配，那么需要加上re.S和re.M标志. 加上re.S后。将会匹配换行符，默认.不会匹配换行符。<br>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"a23b\na34b"</span></span><br><span class="line"> </span><br><span class="line">re.findall(<span class="string">r"a(\d+)b.+a(\d+)b"</span>, str)</span><br><span class="line"><span class="comment">#输出[]</span></span><br><span class="line"><span class="comment">#因为不能处理str中间有\n换行的情况</span></span><br><span class="line"> </span><br><span class="line">re.findall(<span class="string">r"a(\d+)b.+a(\d+)b"</span>, str, re.S)</span><br><span class="line"><span class="comment">#s输出[('23', '34')]</span></span><br></pre></td></tr></table></figure></p><p>加上re.M后,^$标志将会匹配每一行，默认^和$只会匹配第一行。</p><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"a23b\na34b"</span></span><br><span class="line"> </span><br><span class="line">re.findall(<span class="string">r"^a(\d+)b"</span>, str)</span><br><span class="line"><span class="comment">#输出['23']</span></span><br><span class="line"> </span><br><span class="line">re.findall(<span class="string">r"^a(\d+)b"</span>, str, re.M)</span><br><span class="line"><span class="comment">#输出['23', '34']</span></span><br></pre></td></tr></table></figure></p><h2 id="二、连续多个位置的字符串提取"><a href="#二、连续多个位置的字符串提取" class="headerlink" title="二、连续多个位置的字符串提取"></a>二、连续多个位置的字符串提取</h2><p>这种情况我们可以使用(?P<name>…)这个正则表达式来提取。举例，如果我们有一行webserver的access日志:’192.168.0.1 25/Oct/2012:14:46:34 “GET /api HTTP/1.1” 200 44 “<a href="http://abc.com/search&quot;" target="_blank" rel="noopener">http://abc.com/search&quot;</a> “Mozilla/5.0”‘，我们想提取这行日志里面所有的内容，可以写多个(?P<name>expr)来提取,其中name可以更改为你为该位置字符串命名的变量，expr改成提取位置的正则即可。</name></name></p><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">line =<span class="string">'192.168.0.1 25/Oct/2012:14:46:34 "GET /api HTTP/1.1" 200 44 "http://abc.com/search"</span></span><br><span class="line"><span class="string">"Mozilla/5.0"'</span></span><br><span class="line">reg = re.compile(<span class="string">'^(?P&lt;remote_ip&gt;[^ ]*) (?P&lt;date&gt;[^ ]*) "(?P&lt;request&gt;[^"]*)"</span></span><br><span class="line"><span class="string">(?P&lt;status&gt;[^ ]*) (?P&lt;size&gt;[^ ]*) "(?P&lt;referrer&gt;[^"]*)" "(?P&lt;user_agent&gt;[^"]*)"'</span>)</span><br><span class="line">regMatch = reg.match(line)</span><br><span class="line">linebits = regMatch.groupdict()</span><br><span class="line"><span class="keyword">print</span> linebits</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> linebits.items() :</span><br><span class="line"> <span class="keyword">print</span> k+<span class="string">": "</span>+v</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re模块 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python数据处理——Pandas模块使用（二）</title>
      <link href="/2018/05/21/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E2%80%94%E2%80%94Pandas%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/05/21/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E2%80%94%E2%80%94Pandas%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="数据变换操作"><a href="#数据变换操作" class="headerlink" title="数据变换操作"></a>数据变换操作</h2><p><strong>导入文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">odata = pd.read_csv(&apos;example.csv&apos;)</span><br></pre></td></tr></table></figure></p><p>这三行代码就可以实现csv文件的导入，注意文件的路径</p><p><strong>删除行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data1 = data.drop([16,17])</span><br></pre></td></tr></table></figure></p><p><strong>drop()方法</strong></p><p>如果不设置参数inplace=True，则只能在生成的新数据块中实现删除效果，而不能删除原有数据块的相应行。也就是inplace属性可以对原来的数据进行删除操作Inplace = True用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odata.drop(odata.index[[16,17]],inplace=True)</span><br></pre></td></tr></table></figure><p>我们要注意到用与不用inplace的区别，不用inplace的时候，我们使用另外一个变量Data1来暂时保存处理后的数据，而使用inplace的时候，我们直接调用一个函数对原来的数据进行操作。值得注意的是，inplace属性并不会修改原来的文件，所以是安全的。也就是虽然直接对原来数据删除，但并不会删除到文件，只会在内存里操作原来变量。<br>删除列del data[‘date’]<br>代码如上所示，直接删除，注意这个del的方括号里只能够有一个参数。一次只能删除一列。</p><p><strong>pop()方法</strong></p><p>pop方法可以将所选列从原数据块中弹出，原数据块不再保留该列，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data1=data.pop(‘latitude’)</span><br></pre></td></tr></table></figure><p>pop方法将单独的数据取出来，在我们想要对某一块数据很感兴趣的时候非常实用。</p><p><strong>split()的使用</strong></p><p>简单的Python的字符串分割我们在数据预处理的时候很多时候要对一串带有各种符号的数据进行处理。但是实际运行时我们要将它们分开处理，所以需要用到python带的split函数来处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str = (&apos;www.google.com&apos;)</span><br><span class="line">print (str)</span><br><span class="line">str_split = str.split(&apos;.&apos;)</span><br><span class="line">print (str_split)</span><br><span class="line"></span><br><span class="line"># 这样运行出来的结果是</span><br><span class="line"># www.google.com</span><br><span class="line"># [‘www’,‘google’,‘com’]</span><br></pre></td></tr></table></figure><p>如果我们想要设置分割的个数，就在split里面添加参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str_split = str.split(‘.’,1)</span><br><span class="line"># 这样得出的结果是：</span><br><span class="line"># www.google.com</span><br><span class="line"># [‘www’,’google.com’]</span><br></pre></td></tr></table></figure><p>也就是只分割了第一个字符，第二个就没有分割了。</p><h2 id="数据框合并concat-操作"><a href="#数据框合并concat-操作" class="headerlink" title="数据框合并concat()操作"></a>数据框合并concat()操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">concat函数是在pandas底下的方法，可以将数据根据不同的轴作简单的融合</span><br><span class="line">pd.concat(objs, axis=0, join=&apos;outer&apos;, join_axes=None, ignore_index=False,</span><br><span class="line">       keys=None, levels=None, names=None, verify_integrity=False)</span><br></pre></td></tr></table></figure><p>参数说明<br>objs: series，dataframe或者是panel构成的序列lsit<br>axis： 需要合并链接的轴，0是行，1是列<br>join：连接的方式 inner，或者outer</p><p><strong>相同字段的表首尾相接</strong></p><p><img src="https://img-blog.csdn.net/20160913192849769" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 现将表构成list，然后在作为concat的输入</span><br><span class="line">In [4]: frames = [df1, df2, df3]</span><br><span class="line"></span><br><span class="line">In [5]: result = pd.concat(frames)</span><br></pre></td></tr></table></figure><p>要在相接的时候在加上一个层次的key来识别数据源自于哪张表，可以增加key参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.concat(frames, keys=[&apos;x&apos;, &apos;y&apos;, &apos;z&apos;])</span><br></pre></td></tr></table></figure><p>效果如下<br><img src="https://img-blog.csdn.net/20160913194106249" alt="这里写图片描述"></p><p><strong>横向表拼接（行对齐）</strong></p><p>当axis = 1的时候，concat就是行对齐，然后将不同列名称的两张表合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.concat([df1, df4], axis=1)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160913194820155" alt="这里写图片描述"></p><p><strong>join</strong></p><p>加上join参数的属性，如果为’inner’得到的是两表的交集，如果是outer，得到的是两表的并集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.concat([df1, df4], axis=1, join=&apos;inner&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160913195018721" alt="这里写图片描述"></p><p> <strong>join_axes</strong></p><p>如果有join_axes的参数传入，可以指定根据那个轴来对齐数据<br>例如根据df1表对齐数据，就会保留指定的df1表的轴，然后将df4的表与之拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.concat([df1, df4], axis=1, join_axes=[df1.index])</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160913195355535" alt="这里写图片描述"></p><p><strong>append</strong></p><p>append是series和dataframe的方法，使用它就是默认沿着列进行凭借（axis = 0，列对齐）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = df1.append(df2)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160913195644364" alt="这里写图片描述"></p><p><strong>无视index的concat</strong></p><p>如果两个表的index都没有实际含义，使用ignore_index参数，置true，合并的两个表就睡根据列字段对齐，然后合并。最后再重新整理一个新的index。<br><img src="https://img-blog.csdn.net/20160913200428629" alt="这里写图片描述"></p><p><strong>合并的同时增加区分数据组的键</strong></p><p>前面提到的keys参数可以用来给合并后的表增加key来区分不同的表数据来源</p><ol><li>直接用key参数实现</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.concat(frames, keys=[&apos;x&apos;, &apos;y&apos;, &apos;z&apos;])</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160913201130231" alt="这里写图片描述"></p><ol start="2"><li>传入字典来增加分组键</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pieces = &#123;&apos;x&apos;: df1, &apos;y&apos;: df2, &apos;z&apos;: df3&#125;</span><br><span class="line">result = pd.concat(pieces)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160913201130231" alt="这里写图片描述"></p><p><strong>在dataframe中加入新的行</strong></p><p>append方法可以将 series 和 字典就够的数据作为dataframe的新一行插入。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s2 = pd.Series([&apos;X0&apos;, &apos;X1&apos;, &apos;X2&apos;, &apos;X3&apos;], index=[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;])</span><br><span class="line">result = df1.append(s2, ignore_index=True)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160914090542084" alt="这里写图片描述"></p><p><strong>表格列字段不同的表合并</strong></p><p>如果遇到两张表的列字段本来就不一样，但又想将两个表合并，其中无效的值用nan来表示。那么可以使用ignore_index来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dicts = [&#123;&apos;A&apos;: 1, &apos;B&apos;: 2, &apos;C&apos;: 3, &apos;X&apos;: 4&#125;,&#123;&apos;A&apos;: 5, &apos;B&apos;: 6, &apos;C&apos;: 7, &apos;Y&apos;: 8&#125;]</span><br><span class="line">result = df1.append(dicts, ignore_index=True)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160914091035307" alt="这里写代码片"></p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
            <tag> pandas学习 </tag>
            
            <tag> 数据框操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>已解决：用anaconda安装最新的TensorFlow版本</title>
      <link href="/2018/05/21/%E5%B7%B2%E8%A7%A3%E5%86%B3%EF%BC%9A%E7%94%A8anaconda%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%9A%84TensorFlow%E7%89%88%E6%9C%AC/"/>
      <url>/2018/05/21/%E5%B7%B2%E8%A7%A3%E5%86%B3%EF%BC%9A%E7%94%A8anaconda%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%9A%84TensorFlow%E7%89%88%E6%9C%AC/</url>
      <content type="html"><![CDATA[<h1 id="用anaconda安装最新的TensorFlow版本"><a href="#用anaconda安装最新的TensorFlow版本" class="headerlink" title="用anaconda安装最新的TensorFlow版本"></a>用anaconda安装最新的TensorFlow版本</h1><h2 id="存在问题："><a href="#存在问题：" class="headerlink" title="存在问题："></a>存在问题：</h2><p>一般从anaconda官网下载的anaconda，查看tensorflow依然还是1.2的版本，现在用conda更新TensorFlow</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>1，打开anaconda-prompt</p><p>2，查看tensorflow各个版本：（查看会发现有一大堆TensorFlow源，但是不能随便选，选择可以用查找命令定位）</p><p>anaconda search -t conda tensorflow<br>4，找到自己安装环境对应的最新TensorFlow后（可以在终端搜索anaconda，定位到那一行），然后查看安装命令</p><p>anaconda show &lt;USER/PACKAGE&gt;<br>安装anaconda/tensorflow具体操作命令：</p><p>anaconda show anaconda/tensorflow<br>5，第4步会提供一个下载地址，使用下面命令就可安装新版本tensorflow</p><p>conda install –channel <a href="https://conda.anaconda.org/anaconda" target="_blank" rel="noopener">https://conda.anaconda.org/anaconda</a> tensorflow</p>]]></content>
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python数据处理——Pandas模块使用（一）</title>
      <link href="/2018/05/20/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E2%80%94%E2%80%94Pandas%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/05/20/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E2%80%94%E2%80%94Pandas%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="一、Pandas介绍"><a href="#一、Pandas介绍" class="headerlink" title="一、Pandas介绍"></a>一、Pandas介绍</h2><p>在处理实际的金融数据时，一个条数据通常包含了多种类型的数据，例如，股票的代码是字符串，收盘价是浮点型，而成交量是整型等。在C++中可以实现为一个给定结构体作为单元的容器，如向量（vector，C++中的特定数据结构）。在Python中，pandas包含了高级的数据结构Series和DataFrame，使得在Python中处理数据变得非常方便、快速和简单。pandas不同的版本之间存在一些不兼容性，为此，我们需要清楚使用的是哪一个版本的pandas。</p><h2 id="二、Pandas数据结构介绍"><a href="#二、Pandas数据结构介绍" class="headerlink" title="二、Pandas数据结构介绍"></a>二、Pandas数据结构介绍</h2><p>在pandas中有两类非常重要的数据结构，即序列Series和数据框DataFrame。Series类似于numpy中的一维数组，除了通吃一维数组可用的函数或方法，而且其可通过索引标签的方式获取数据，还具有索引的自动对齐功能；DataFrame类似于numpy中的二维数组，同样可以通用numpy数组的函数和方法，而且还具有其他灵活应用，后续会介绍到。</p><h3 id="1、Series的创建"><a href="#1、Series的创建" class="headerlink" title="1、Series的创建"></a>1、Series的创建</h3><p>Series的创建主要有三种方式：</p><p>1）通过一维数组创建序列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">arr1 = np.arange(<span class="number">5</span>)</span><br><span class="line">print(arr1)</span><br><span class="line">print(type(arr1))</span><br><span class="line">s1 = pd.Series(arr1)</span><br><span class="line">print(s1)</span><br><span class="line">print(type(s1))</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20180507194213523?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjAzNDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="运行结果"><br>2）通过字典的方式创建序列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">arr1 = &#123;<span class="string">'a'</span>:<span class="number">10</span>,<span class="string">'b'</span>:<span class="number">20</span>,<span class="string">'c'</span>:<span class="number">30</span>,<span class="string">'d'</span>:<span class="number">40</span>,<span class="string">'e'</span>:<span class="number">50</span>&#125;</span><br><span class="line">print(arr1)</span><br><span class="line">print(type(arr1))</span><br><span class="line">s1 = pd.Series(arr1)</span><br><span class="line">print(s1)</span><br><span class="line">print(type(s1))</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20180507194528949?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjAzNDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="运行结果"><br>3）通过DataFrame中的某一行或某一列创建序列，具体见DataFrame创建。</p><h3 id="2、DataFrame的创建"><a href="#2、DataFrame的创建" class="headerlink" title="2、DataFrame的创建"></a>2、DataFrame的创建</h3><p>数据框的创建主要有三种方式：</p><p>1）通过二维数组创建数据框</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">arr1 = np.array(np.arange(<span class="number">12</span>)).reshape(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">print(arr1)</span><br><span class="line">print(type(arr1))</span><br><span class="line">df1 = pd.DataFrame(arr1)</span><br><span class="line">print(df1)</span><br><span class="line">print(type(df1))</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180507194926432?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjAzNDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>2）通过字典的方式创建数据框<br>以下以两种字典来创建数据框，一个是字典列表，一个是嵌套字典。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dic1 = &#123;<span class="string">'a'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">'b'</span>: [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">        <span class="string">'c'</span>: [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>], <span class="string">'d'</span>: [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]&#125;</span><br><span class="line">print(dic1)</span><br><span class="line">print(type(dic1))</span><br><span class="line">df1 = pd.DataFrame(dic1)</span><br><span class="line">print(df1)</span><br><span class="line">print(type(df1))</span><br><span class="line"></span><br><span class="line">dic2 = &#123;<span class="string">'one'</span>: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>&#125;,</span><br><span class="line">        <span class="string">'two'</span>: &#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">6</span>, <span class="string">'c'</span>: <span class="number">7</span>, <span class="string">'d'</span>: <span class="number">8</span>&#125;,</span><br><span class="line">        <span class="string">'three'</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>, <span class="string">'b'</span>: <span class="number">10</span>, <span class="string">'c'</span>: <span class="number">11</span>, <span class="string">'d'</span>: <span class="number">12</span>&#125;&#125;</span><br><span class="line">print(dic2)</span><br><span class="line">print(type(dic2))</span><br><span class="line">df2 = pd.DataFrame(dic2)</span><br><span class="line">print(df2)</span><br><span class="line">print(type(df2))</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20180507195512903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjAzNDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>3）通过数据框的方式创建数据框<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df3=df2[[<span class="string">'one'</span>,<span class="string">'three'</span>]]</span><br><span class="line">print(df3)</span><br><span class="line">print(type(df3))</span><br><span class="line">s3 = df3[<span class="string">'one'</span>]</span><br><span class="line">print(s3)</span><br><span class="line">print(type(s3))</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20180507195723401?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjAzNDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="三、数据索引index"><a href="#三、数据索引index" class="headerlink" title="三、数据索引index"></a>三、数据索引index</h2><p>细致的朋友可能会发现一个现象，不论是序列也好，还是数据框也好，对象的最左边总有一个非原始数据对象，这个是什么呢？不错，就是我们接下来要介绍的索引。<br>在我看来，序列或数据框的索引有两大用处，一个是通过索引值或索引标签获取目标数据，另一个是通过索引，可以使序列或数据框的计算、操作实现自动化对齐，下面我们就来看看这两个功能的应用。</p><p>1、通过索引值或索引标签获取数据</p><p>如果不给序列一个指定的索引值，则序列自动生成一个从0开始的自增索引。可以通过index查看序列的索引：</p><p>s4.index<br>现在我们为序列设定一个自定义的索引值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s4 = pd.Series(np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>]))</span><br><span class="line">print(s4)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># 0    1</span></span><br><span class="line"><span class="comment"># 1    1</span></span><br><span class="line"><span class="comment"># 2    2</span></span><br><span class="line"><span class="comment"># 3    3</span></span><br><span class="line"><span class="comment"># 4    5</span></span><br><span class="line"><span class="comment"># 5    8</span></span><br><span class="line"><span class="comment"># dtype: int32</span></span><br></pre></td></tr></table></figure></p><p>序列有了索引，就可以通过索引值或索引标签进行数据的获取：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s4[<span class="number">3</span>]</span><br><span class="line">s4[<span class="string">'e'</span>]</span><br><span class="line">s4[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line">s4[[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>,<span class="string">'f'</span>]]</span><br><span class="line">s4[:<span class="number">4</span>]</span><br><span class="line">s4[<span class="string">'c'</span>:]</span><br><span class="line">s4[<span class="string">'b'</span>:<span class="string">'e'</span>]</span><br></pre></td></tr></table></figure></p><p>千万注意：如果通过索引标签获取数据的话，末端标签所对应的值是可以返回的！在一维数组中，就无法通过索引标签获取数据，这也是序列不同于一维数组的一个方面。</p><p>2、自动化对齐<br>如果有两个序列，需要对这两个序列进行算术运算，这时索引的存在就体现的它的价值了—自动化对齐.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">s5 = pd.Series(np.array([<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">55</span>,<span class="number">80</span>]),</span><br><span class="line">               index = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>])</span><br><span class="line">print(s5)</span><br><span class="line"><span class="comment"># a    10</span></span><br><span class="line"><span class="comment"># b    15</span></span><br><span class="line"><span class="comment"># c    20</span></span><br><span class="line"><span class="comment"># d    30</span></span><br><span class="line"><span class="comment"># e    55</span></span><br><span class="line"><span class="comment"># f    80</span></span><br><span class="line"><span class="comment"># dtype: int32</span></span><br><span class="line">s6 = pd.Series(np.array([<span class="number">12</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">16</span>]),</span><br><span class="line">               index = [<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'g'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>,<span class="string">'f'</span>])</span><br><span class="line">print(s6)</span><br><span class="line"><span class="comment"># a    12</span></span><br><span class="line"><span class="comment"># c    11</span></span><br><span class="line"><span class="comment"># g    13</span></span><br><span class="line"><span class="comment"># b    15</span></span><br><span class="line"><span class="comment"># d    14</span></span><br><span class="line"><span class="comment"># f    16</span></span><br><span class="line"><span class="comment"># dtype: int32</span></span><br><span class="line"></span><br><span class="line">print(s5 + s6)</span><br><span class="line"><span class="comment"># a    22.0</span></span><br><span class="line"><span class="comment"># b    30.0</span></span><br><span class="line"><span class="comment"># c    31.0</span></span><br><span class="line"><span class="comment"># d    44.0</span></span><br><span class="line"><span class="comment"># e     NaN</span></span><br><span class="line"><span class="comment"># f    96.0</span></span><br><span class="line"><span class="comment"># g     NaN</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br><span class="line"></span><br><span class="line">print(s5/s6)</span><br><span class="line"><span class="comment"># a    0.833333</span></span><br><span class="line"><span class="comment"># b    1.000000</span></span><br><span class="line"><span class="comment"># c    1.818182</span></span><br><span class="line"><span class="comment"># d    2.142857</span></span><br><span class="line"><span class="comment"># e         NaN</span></span><br><span class="line"><span class="comment"># f    5.000000</span></span><br><span class="line"><span class="comment"># g         NaN</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br></pre></td></tr></table></figure></p><p>由于s5中没有对应的g索引，s6中没有对应的e索引，所以数据的运算会产生两个缺失值NaN。注意，这里的算术结果就实现了两个序列索引的自动对齐，而非简单的将两个序列加总或相除。对于数据框的对齐，不仅仅是行索引的自动对齐，同时也会自动对齐列索引（变量名）</p><p>数据框中同样有索引，而且数据框是二维数组的推广，所以其不仅有行索引，而且还存在列索引，关于数据框中的索引相比于序列的应用要强大的多，这部分内容将放在数据查询中讲解。</p><h2 id="四、利用pandas查询数据"><a href="#四、利用pandas查询数据" class="headerlink" title="四、利用pandas查询数据"></a>四、利用pandas查询数据</h2><p>这里的查询数据相当于R语言里的subset功能，可以通过布尔索引有针对的选取原数据的子集、指定行、指定列等。我们先导入一个student数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">student = pd.io.parsers.read_csv(<span class="string">'C:\\Users\\admin\\Desktop\\student.csv'</span>)</span><br><span class="line"><span class="comment"># 查询数据的前5行或末尾5行</span></span><br><span class="line"></span><br><span class="line">student.head()</span><br><span class="line">student.tail()</span><br><span class="line"><span class="comment"># 查询指定的行</span></span><br><span class="line"></span><br><span class="line">student.ix[[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>]] <span class="comment">#这里的ix索引标签函数必须是中括号[]</span></span><br><span class="line"><span class="comment"># 查询指定的列</span></span><br><span class="line"></span><br><span class="line">student[[<span class="string">'Name'</span>,<span class="string">'Height'</span>,<span class="string">'Weight'</span>]].head()  <span class="comment">#如果多个列的话，必须使用双重中括号</span></span><br><span class="line"><span class="comment"># 也可以通过ix索引标签查询指定的列</span></span><br><span class="line"></span><br><span class="line">student.ix[:,[<span class="string">'Name'</span>,<span class="string">'Height'</span>,<span class="string">'Weight'</span>]].head()</span><br><span class="line"><span class="comment"># 查询指定的行和列</span></span><br><span class="line"></span><br><span class="line">student.ix[[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="string">'Name'</span>,<span class="string">'Height'</span>,<span class="string">'Weight'</span>]].head()</span><br><span class="line"><span class="comment"># 以上是从行或列的角度查询数据的子集，现在我们来看看如何通过布尔索引实现数据的子集查询。</span></span><br><span class="line"><span class="comment"># 查询所有女生的信息</span></span><br><span class="line"></span><br><span class="line">student[student[<span class="string">'Sex'</span>]==<span class="string">'F'</span>]</span><br><span class="line"><span class="comment"># 查询出所有12岁以上的女生信息</span></span><br><span class="line"></span><br><span class="line">student[(student[<span class="string">'Sex'</span>]==<span class="string">'F'</span>) &amp; (student[<span class="string">'Age'</span>]&gt;<span class="number">12</span>)]</span><br><span class="line">查询出所有<span class="number">12</span>岁以上的女生姓名、身高和体重</span><br><span class="line"></span><br><span class="line">student[(student[<span class="string">'Sex'</span>]==<span class="string">'F'</span>) &amp; (student[<span class="string">'Age'</span>]&gt;<span class="number">12</span>)][[<span class="string">'Name'</span>,<span class="string">'Height'</span>,<span class="string">'Weight'</span>]]</span><br></pre></td></tr></table></figure><p>上面的查询逻辑其实非常的简单，需要注意的是，如果是多个条件的查询，必须在&amp;（且）或者|（或）的两端条件用括号括起来。</p><h2 id="五、统计分析"><a href="#五、统计分析" class="headerlink" title="五、统计分析"></a>五、统计分析</h2><p>pandas模块为我们提供了非常多的描述性统计分析的指标函数，如总和、均值、最小值、最大值等，我们来具体看看这些函数：<br>首先随机生成三组数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1234</span>)</span><br><span class="line">d1 = pd.Series(<span class="number">2</span>*np.random.normal(size = <span class="number">100</span>)+<span class="number">3</span>)</span><br><span class="line">d2 = np.random.f(<span class="number">2</span>,<span class="number">4</span>,size = <span class="number">100</span>)</span><br><span class="line">d3 = np.random.randint(<span class="number">1</span>,<span class="number">100</span>,size = <span class="number">100</span>)</span><br><span class="line">d1.count()  <span class="comment">#非空元素计算</span></span><br><span class="line">d1.min()    <span class="comment">#最小值</span></span><br><span class="line">d1.max()    <span class="comment">#最大值</span></span><br><span class="line">d1.idxmin() <span class="comment">#最小值的位置，类似于R中的which.min函数</span></span><br><span class="line">d1.idxmax() <span class="comment">#最大值的位置，类似于R中的which.max函数</span></span><br><span class="line">d1.quantile(<span class="number">0.1</span>)    <span class="comment">#10%分位数</span></span><br><span class="line">d1.sum()    <span class="comment">#求和</span></span><br><span class="line">d1.mean()   <span class="comment">#均值</span></span><br><span class="line">d1.median() <span class="comment">#中位数</span></span><br><span class="line">d1.mode()   <span class="comment">#众数</span></span><br><span class="line">d1.var()    <span class="comment">#方差</span></span><br><span class="line">d1.std()    <span class="comment">#标准差</span></span><br><span class="line">d1.mad()    <span class="comment">#平均绝对偏差</span></span><br><span class="line">d1.skew()   <span class="comment">#偏度</span></span><br><span class="line">d1.kurt()   <span class="comment">#峰度</span></span><br><span class="line">d1.describe()   <span class="comment">#一次性输出多个描述性统计指标</span></span><br></pre></td></tr></table></figure></p><p>必须注意的是，descirbe方法只能针对序列或数据框，一维数组是没有这个方法的。<br>这里自定义一个函数，将这些统计描述指标全部汇总到一起:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stats</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pd.Series([x.count(),x.min(),x.idxmin(),</span><br><span class="line">               x.quantile(<span class="number">.25</span>),x.median(),</span><br><span class="line">               x.quantile(<span class="number">.75</span>),x.mean(),</span><br><span class="line">               x.max(),x.idxmax(),</span><br><span class="line">               x.mad(),x.var(),</span><br><span class="line">               x.std(),x.skew(),x.kurt()],</span><br><span class="line">              index = [<span class="string">'Count'</span>,<span class="string">'Min'</span>,<span class="string">'Whicn_Min'</span>,</span><br><span class="line">                       <span class="string">'Q1'</span>,<span class="string">'Median'</span>,<span class="string">'Q3'</span>,<span class="string">'Mean'</span>,</span><br><span class="line">                       <span class="string">'Max'</span>,<span class="string">'Which_Max'</span>,<span class="string">'Mad'</span>,</span><br><span class="line">                       <span class="string">'Var'</span>,<span class="string">'Std'</span>,<span class="string">'Skew'</span>,<span class="string">'Kurt'</span>])</span><br><span class="line">stats(d1)</span><br></pre></td></tr></table></figure><p>在实际的工作中，我们可能需要处理的是一系列的数值型数据框，如何将这个函数应用到数据框中的每一列呢？可以使用apply函数，这个非常类似于R中的apply的应用方法。<br>将之前创建的d1,d2,d3数据构建数据框:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.array([d1,d2,d3]).T,columns=[<span class="string">'x1'</span>,<span class="string">'x2'</span>,<span class="string">'x3'</span>])</span><br><span class="line">df.head()</span><br><span class="line">df.apply(stats)</span><br></pre></td></tr></table></figure><p>非常完美，就这样很简单的创建了数值型数据的统计性描述。如果是离散型数据呢？就不能用这个统计口径了，我们需要统计离散变量的观测数、唯一值个数、众数水平及个数。你只需要使用describe方法就可以实现这样的统计了。<br>student[‘Sex’].describe()</p><p>除以上的简单描述性统计之外，还提供了连续变量的相关系数（corr）和协方差矩阵（cov）的求解，这个跟R语言是一致的用法。<br>df.corr()</p><p>关于相关系数的计算可以调用pearson方法或kendell方法或spearman方法，默认使用pearson方法。<br>df.corr(‘spearman’)</p><p>如果只想关注某一个变量与其余变量的相关系数的话，可以使用corrwith,如下方只关心x1与其余变量的相关系数:<br>df.corrwith(df[‘x1’])</p><p>数值型变量间的协方差矩阵<br>df.cov()</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
            <tag> pandas学习 </tag>
            
            <tag> 数据框操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gooday</title>
      <link href="/2018/05/19/gooday/"/>
      <url>/2018/05/19/gooday/</url>
      <content type="html"><![CDATA[<h1 id="回归模型代码"><a href="#回归模型代码" class="headerlink" title="回归模型代码"></a>回归模型代码</h1><p>…<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> plot_importance</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># read in the iris data</span></span><br><span class="line">iris = load_iris()</span><br><span class="line"></span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">1234565</span>)</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'booster'</span>: <span class="string">'gbtree'</span>,</span><br><span class="line">    <span class="string">'objective'</span>: <span class="string">'multi:softmax'</span>,</span><br><span class="line">    <span class="string">'num_class'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'gamma'</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">'max_depth'</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">'lambda'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'subsample'</span>: <span class="number">0.7</span>,</span><br><span class="line">    <span class="string">'colsample_bytree'</span>: <span class="number">0.7</span>,</span><br><span class="line">    <span class="string">'min_child_weight'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'silent'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'eta'</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">'seed'</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="string">'nthread'</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">'num_rounds'</span> : <span class="number">500</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plst = params.items()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dtrain = xgb.DMatrix(X_train, y_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = xgb.train(plst, dtrain)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对测试集进行预测</span></span><br><span class="line">dtest = xgb.DMatrix(X_test)</span><br><span class="line">ans = model.predict(dtest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">cnt1 = <span class="number">0</span></span><br><span class="line">cnt2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(y_test)):</span><br><span class="line">    <span class="keyword">if</span> ans[i] == y_test[i]:</span><br><span class="line">        cnt1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cnt2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Accuracy: %.2f %% "</span> % (<span class="number">100</span> * cnt1 / (cnt1 + cnt2)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示重要特征</span></span><br><span class="line">plot_importance(model)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xgboost </tag>
            
            <tag> 回归模型 </tag>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/19/hello-world/"/>
      <url>/2018/05/19/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> next主题 </tag>
            
            <tag> 博客建站 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
