<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>python的列表list和集合set操作</title>
      <link href="/2018/05/21/python%E7%9A%84%E5%88%97%E8%A1%A8list%E5%92%8C%E9%9B%86%E5%90%88set%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/05/21/python%E7%9A%84%E5%88%97%E8%A1%A8list%E5%92%8C%E9%9B%86%E5%90%88set%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="以下是一些python的list和set的基本操作"><a href="#以下是一些python的list和set的基本操作" class="headerlink" title="以下是一些python的list和set的基本操作"></a>以下是一些python的list和set的基本操作</h2><h3 id="1-list的一些操作"><a href="#1-list的一些操作" class="headerlink" title="1.list的一些操作"></a>1.list的一些操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list.append(<span class="number">5</span>)</span><br><span class="line">print(list)</span><br><span class="line"></span><br><span class="line">list.extend([<span class="number">7</span>, <span class="number">8</span>])  <span class="comment"># extend是将可迭代对象的元素依次加入列表</span></span><br><span class="line">print(list)</span><br><span class="line"></span><br><span class="line">list.append([<span class="number">7</span>, <span class="number">8</span>])  <span class="comment"># append是把传入的参数当成一个元素加入列表</span></span><br><span class="line">print(list)</span><br><span class="line"></span><br><span class="line">list.reverse()  <span class="comment"># 元素翻转，注意不能将这个操作赋给一个变量，此操作是对list本身操作，即list自身发生变化</span></span><br><span class="line"><span class="comment"># l=list.reverse() l为空，没有得到list翻转后的值</span></span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="./1526910408350.png" alt="Alt text"></p><h3 id="2-set基本操作"><a href="#2-set基本操作" class="headerlink" title="2.set基本操作"></a>2.set基本操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">s = set(list)</span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># s.add([2,3]) 错误，add函数只能增加与原集合相同类型的元素</span></span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line">s.update([<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="comment"># s.update(5) 错误，update更新集合时传入的是一个可迭代对象</span></span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line">c = s.copy()  <span class="comment"># 用于集合复制,创建新集合</span></span><br><span class="line">cc = s</span><br><span class="line">print(c)</span><br><span class="line">print(cc)</span><br><span class="line"><span class="comment"># 类似于list中copy方法</span></span><br><span class="line">print(cc <span class="keyword">is</span> c)</span><br><span class="line"></span><br><span class="line">ss = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>&#125;</span><br><span class="line">minus = s.difference(ss)  <span class="comment"># 求差集</span></span><br><span class="line">print(minus)</span><br><span class="line"></span><br><span class="line">union = s.union(ss)  <span class="comment"># 求并集</span></span><br><span class="line">print(union)</span><br><span class="line"></span><br><span class="line">intersection = s.intersection(ss)  <span class="comment"># 求交集</span></span><br><span class="line">print(intersection)</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="./1526910433830.png" alt="Alt text"></p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TensorFlow中张量增加纬度和词向量查找一些操作</title>
      <link href="/2018/05/21/TensorFlow%E4%B8%AD%E5%BC%A0%E9%87%8F%E5%A2%9E%E5%8A%A0%E7%BA%AC%E5%BA%A6%E5%92%8C%E8%AF%8D%E5%90%91%E9%87%8F%E6%9F%A5%E6%89%BE%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/05/21/TensorFlow%E4%B8%AD%E5%BC%A0%E9%87%8F%E5%A2%9E%E5%8A%A0%E7%BA%AC%E5%BA%A6%E5%92%8C%E8%AF%8D%E5%90%91%E9%87%8F%E6%9F%A5%E6%89%BE%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="TensorFlow中embedding-lookup操作"><a href="#TensorFlow中embedding-lookup操作" class="headerlink" title="TensorFlow中embedding_lookup操作"></a>TensorFlow中embedding_lookup操作</h2><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">a=tf.Variable(tf.random_normal([<span class="number">2</span>,<span class="number">4</span>]),tf.float32)</span><br><span class="line">b=tf.Variable(tf.random_normal([<span class="number">2</span>,<span class="number">3</span>]),tf.float32)</span><br><span class="line">c=tf.Variable(tf.random_normal([<span class="number">2</span>,<span class="number">3</span>]),tf.float32)</span><br><span class="line"></span><br><span class="line">em=tf.nn.embedding_lookup(a,[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">p1=tf.nn.embedding_lookup(b,[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">d=tf.expand_dims(tf.concat([em,p1],<span class="number">-1</span>),<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'a\n'</span>,sess.run(a))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'em\n'</span>,sess.run(em))</span><br><span class="line">    print(<span class="string">'p1\n'</span>, sess.run(p1))</span><br><span class="line">    print(<span class="string">'d\n'</span>,sess.run(d))</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20180415140747571?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjAzNDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="enter image description here"></p>]]></content>
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> embedding_lookup </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TensorFlow中常用函数说明</title>
      <link href="/2018/05/21/TensorFlow%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/"/>
      <url>/2018/05/21/TensorFlow%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<h3 id="本文主要对TensorFlow的一些常用概念与方法进行描述，TensorFlow常用函数如下："><a href="#本文主要对TensorFlow的一些常用概念与方法进行描述，TensorFlow常用函数如下：" class="headerlink" title="本文主要对TensorFlow的一些常用概念与方法进行描述，TensorFlow常用函数如下："></a>本文主要对TensorFlow的一些常用概念与方法进行描述，TensorFlow常用函数如下：</h3><p>转载地址：<a href="https://blog.csdn.net/lenbow/article/details/52152766" target="_blank" rel="noopener">https://blog.csdn.net/lenbow/article/details/52152766</a></p><h2 id="tf函数"><a href="#tf函数" class="headerlink" title="tf函数"></a>tf函数</h2><table><thead><tr><th style="text-align:left">操作组</th><th style="text-align:right">操作</th></tr></thead><tbody><tr><td style="text-align:left">Maths</td><td style="text-align:right">Add, Sub, Mul, Div, Exp, Log, Greater, Less, Equal</td></tr><tr><td style="text-align:left">Array</td><td style="text-align:right">Concat, Slice, Split, Constant, Rank, Shape, Shuffle</td></tr><tr><td style="text-align:left">Matrix</td><td style="text-align:right">MatMul, MatrixInverse, MatrixDeterminant</td></tr><tr><td style="text-align:left">Neuronal Network</td><td style="text-align:right">SoftMax, Sigmoid, ReLU, Convolution2D, MaxPool</td></tr><tr><td style="text-align:left">Queues and syncronizations</td><td style="text-align:right">Enqueue, Dequeue, MutexAcquire, MutexRelease</td></tr><tr><td style="text-align:left">Flow control</td><td style="text-align:right">Merge, Switch, Enter, Leave, NextIteration</td></tr></tbody></table><p>TensorFlow的算术操作如下：<br>操作    描述<br>tf.add(x, y, name=None)    求和<br>tf.sub(x, y, name=None)    减法<br>tf.mul(x, y, name=None)    乘法<br>tf.div(x, y, name=None)    除法<br>tf.mod(x, y, name=None)    取模<br>tf.abs(x, name=None)    求绝对值<br>tf.neg(x, name=None)    取负 (y = -x).<br>tf.sign(x, name=None)    返回符号 y = sign(x) = -1 if x &lt; 0; 0 if x == 0; 1 if x &gt; 0.<br>tf.inv(x, name=None)    取反<br>tf.square(x, name=None)    计算平方 (y = x * x = x^2).<br>tf.round(x, name=None)    舍入最接近的整数</p><p>#‘a’ is [0.9, 2.5, 2.3, -4.4]<br>tf.round(a) ==&gt; [ 1.0, 3.0, 2.0, -4.0 ]<br>tf.sqrt(x, name=None)    开根号 (y = \sqrt{x} = x^{1/2}).<br>tf.pow(x, y, name=None)    幂次方 </p><p>#tensor ‘x’ is [[2, 2], [3, 3]]</p><h1 id="tensor-‘y’-is-8-16-2-3"><a href="#tensor-‘y’-is-8-16-2-3" class="headerlink" title="tensor ‘y’ is [[8, 16], [2, 3]]"></a>tensor ‘y’ is [[8, 16], [2, 3]]</h1><p>tf.pow(x, y) ==&gt; [[256, 65536], [9, 27]]<br>tf.exp(x, name=None)    计算e的次方<br>tf.log(x, name=None)    计算log，一个输入计算e的ln，两输入以第二输入为底<br>tf.maximum(x, y, name=None)    返回最大值 (x &gt; y ? x : y)<br>tf.minimum(x, y, name=None)    返回最小值 (x &lt; y ? x : y)<br>tf.cos(x, name=None)    三角函数cosine<br>tf.sin(x, name=None)    三角函数sine<br>tf.tan(x, name=None)    三角函数tan<br>tf.atan(x, name=None)    三角函数ctan<br>张量操作Tensor Transformations<br>数据类型转换Casting<br>操作    描述<br>tf.string_to_number<br>(string_tensor, out_type=None, name=None)    字符串转为数字<br>tf.to_double(x, name=’ToDouble’)    转为64位浮点类型–float64<br>tf.to_float(x, name=’ToFloat’)    转为32位浮点类型–float32<br>tf.to_int32(x, name=’ToInt32’)    转为32位整型–int32<br>tf.to_int64(x, name=’ToInt64’)    转为64位整型–int64<br>tf.cast(x, dtype, name=None)    将x或者x.values转换为dtype</p><h1 id="tensor-a-is-1-8-2-2-dtype-tf-float"><a href="#tensor-a-is-1-8-2-2-dtype-tf-float" class="headerlink" title="tensor a is [1.8, 2.2], dtype=tf.float"></a>tensor a is [1.8, 2.2], dtype=tf.float</h1><p>tf.cast(a, tf.int32) ==&gt; [1, 2] # dtype=tf.int32</p><p>形状操作Shapes and Shaping<br>操作    描述<br>tf.shape(input, name=None)    返回数据的shape</p><h1 id="‘t’-is-1-1-1-2-2-2-3-3-3-4-4-4"><a href="#‘t’-is-1-1-1-2-2-2-3-3-3-4-4-4" class="headerlink" title="‘t’ is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]"></a>‘t’ is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]</h1><p>shape(t) ==&gt; [2, 2, 3]<br>tf.size(input, name=None)    返回数据的元素数量</p><h1 id="‘t’-is-1-1-1-2-2-2-3-3-3-4-4-4-1"><a href="#‘t’-is-1-1-1-2-2-2-3-3-3-4-4-4-1" class="headerlink" title="‘t’ is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]"></a>‘t’ is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]</h1><p>size(t) ==&gt; 12<br>tf.rank(input, name=None)    返回tensor的rank<br>注意：此rank不同于矩阵的rank，<br>tensor的rank表示一个tensor需要的索引数目来唯一表示任何一个元素<br>也就是通常所说的 “order”, “degree”或”ndims”</p><p>#’t’ is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]</p><h1 id="shape-of-tensor-‘t’-is-2-2-3"><a href="#shape-of-tensor-‘t’-is-2-2-3" class="headerlink" title="shape of tensor ‘t’ is [2, 2, 3]"></a>shape of tensor ‘t’ is [2, 2, 3]</h1><p>rank(t) ==&gt; 3<br>tf.reshape(tensor, shape, name=None)    改变tensor的形状</p><h1 id="tensor-‘t’-is-1-2-3-4-5-6-7-8-9"><a href="#tensor-‘t’-is-1-2-3-4-5-6-7-8-9" class="headerlink" title="tensor ‘t’ is [1, 2, 3, 4, 5, 6, 7, 8, 9]"></a>tensor ‘t’ is [1, 2, 3, 4, 5, 6, 7, 8, 9]</h1><h1 id="tensor-‘t’-has-shape-9"><a href="#tensor-‘t’-has-shape-9" class="headerlink" title="tensor ‘t’ has shape [9]"></a>tensor ‘t’ has shape [9]</h1><p>reshape(t, [3, 3]) ==&gt;<br>[[1, 2, 3],<br>[4, 5, 6],<br>[7, 8, 9]]</p><p>#如果shape有元素[-1],表示在该维度打平至一维</p><h1 id="1-将自动推导得为-9"><a href="#1-将自动推导得为-9" class="headerlink" title="-1 将自动推导得为 9:"></a>-1 将自动推导得为 9:</h1><p>reshape(t, [2, -1]) ==&gt;<br>[[1, 1, 1, 2, 2, 2, 3, 3, 3],<br>[4, 4, 4, 5, 5, 5, 6, 6, 6]]<br>tf.expand_dims(input, dim, name=None)    插入维度1进入一个tensor中</p><p>#该操作要求-1-input.dims()</p><h1 id="‘t’-is-a-tensor-of-shape-2"><a href="#‘t’-is-a-tensor-of-shape-2" class="headerlink" title="‘t’ is a tensor of shape [2]"></a>‘t’ is a tensor of shape [2]</h1><p>shape(expand_dims(t, 0)) ==&gt; [1, 2]<br>shape(expand_dims(t, 1)) ==&gt; [2, 1]<br>shape(expand_dims(t, -1)) ==&gt; [2, 1] &lt;= dim &lt;= input.dims()<br>切片与合并（Slicing and Joining）<br>操作    描述<br>tf.slice(input_, begin, size, name=None)    对tensor进行切片操作<br>其中size[i] = input.dim_size(i) - begin[i]<br>该操作要求 0 &lt;= begin[i] &lt;= begin[i] + size[i] &lt;= Di for i in [0, n]</p><p>#’input’ is </p><p>#[[[1, 1, 1], [2, 2, 2]],[[3, 3, 3], [4, 4, 4]],[[5, 5, 5], [6, 6, 6]]]<br>tf.slice(input, [1, 0, 0], [1, 1, 3]) ==&gt; [[[3, 3, 3]]]<br>tf.slice(input, [1, 0, 0], [1, 2, 3]) ==&gt;<br>[[[3, 3, 3],<br>[4, 4, 4]]]<br>tf.slice(input, [1, 0, 0], [2, 1, 3]) ==&gt;<br>[[[3, 3, 3]],<br>[[5, 5, 5]]]<br>tf.split(split_dim, num_split, value, name=’split’)    沿着某一维度将tensor分离为num_split tensors</p><h1 id="‘value’-is-a-tensor-with-shape-5-30"><a href="#‘value’-is-a-tensor-with-shape-5-30" class="headerlink" title="‘value’ is a tensor with shape [5, 30]"></a>‘value’ is a tensor with shape [5, 30]</h1><h1 id="Split-‘value’-into-3-tensors-along-dimension-1"><a href="#Split-‘value’-into-3-tensors-along-dimension-1" class="headerlink" title="Split ‘value’ into 3 tensors along dimension 1"></a>Split ‘value’ into 3 tensors along dimension 1</h1><p>split0, split1, split2 = tf.split(1, 3, value)<br>tf.shape(split0) ==&gt; [5, 10]<br>tf.concat(concat_dim, values, name=’concat’)    沿着某一维度连结tensor<br>t1 = [[1, 2, 3], [4, 5, 6]]<br>t2 = [[7, 8, 9], [10, 11, 12]]<br>tf.concat(0, [t1, t2]) ==&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]<br>tf.concat(1, [t1, t2]) ==&gt; [[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]]<br>如果想沿着tensor一新轴连结打包,那么可以：<br>tf.concat(axis, [tf.expand_dims(t, axis) for t in tensors])<br>等同于tf.pack(tensors, axis=axis)<br>tf.pack(values, axis=0, name=’pack’)    将一系列rank-R的tensor打包为一个rank-(R+1)的tensor</p><h1 id="‘x’-is-1-4-‘y’-is-2-5-‘z’-is-3-6"><a href="#‘x’-is-1-4-‘y’-is-2-5-‘z’-is-3-6" class="headerlink" title="‘x’ is [1, 4], ‘y’ is [2, 5], ‘z’ is [3, 6]"></a>‘x’ is [1, 4], ‘y’ is [2, 5], ‘z’ is [3, 6]</h1><p>pack([x, y, z]) =&gt; [[1, 4], [2, 5], [3, 6]] </p><h1 id="沿着第一维pack"><a href="#沿着第一维pack" class="headerlink" title="沿着第一维pack"></a>沿着第一维pack</h1><p>pack([x, y, z], axis=1) =&gt; [[1, 2, 3], [4, 5, 6]]<br>等价于tf.pack([x, y, z]) = np.asarray([x, y, z])<br>tf.reverse(tensor, dims, name=None)    沿着某维度进行序列反转<br>其中dim为列表，元素为bool型，size等于rank(tensor)</p><h1 id="tensor-‘t’-is"><a href="#tensor-‘t’-is" class="headerlink" title="tensor ‘t’ is"></a>tensor ‘t’ is</h1><p>[[[[ 0, 1, 2, 3],</p><p>#[ 4, 5, 6, 7],</p><p>#[ 8, 9, 10, 11]],</p><p>#[[12, 13, 14, 15],</p><p>#[16, 17, 18, 19],</p><p>#[20, 21, 22, 23]]]]</p><h1 id="tensor-‘t’-shape-is-1-2-3-4"><a href="#tensor-‘t’-shape-is-1-2-3-4" class="headerlink" title="tensor ‘t’ shape is [1, 2, 3, 4]"></a>tensor ‘t’ shape is [1, 2, 3, 4]</h1><h1 id="‘dims’-is-False-False-False-True"><a href="#‘dims’-is-False-False-False-True" class="headerlink" title="‘dims’ is [False, False, False, True]"></a>‘dims’ is [False, False, False, True]</h1><p>reverse(t, dims) ==&gt;<br>[[[[ 3, 2, 1, 0],<br>[ 7, 6, 5, 4],<br>[ 11, 10, 9, 8]],<br>[[15, 14, 13, 12],<br>[19, 18, 17, 16],<br>[23, 22, 21, 20]]]]<br>tf.transpose(a, perm=None, name=’transpose’)    调换tensor的维度顺序<br>按照列表perm的维度排列调换tensor顺序，<br>如为定义，则perm为(n-1…0)</p><h1 id="‘x’-is-1-2-3-4-5-6"><a href="#‘x’-is-1-2-3-4-5-6" class="headerlink" title="‘x’ is [[1 2 3],[4 5 6]]"></a>‘x’ is [[1 2 3],[4 5 6]]</h1><p>tf.transpose(x) ==&gt; [[1 4], [2 5],[3 6]]</p><h1 id="Equivalently"><a href="#Equivalently" class="headerlink" title="Equivalently"></a>Equivalently</h1><p>tf.transpose(x, perm=[1, 0]) ==&gt; [[1 4],[2 5], [3 6]]<br>tf.gather(params, indices, validate_indices=None, name=None)    合并索引indices所指示params中的切片<br>tf.gather<br>tf.one_hot<br>(indices, depth, on_value=None, off_value=None,<br>axis=None, dtype=None, name=None)    indices = [0, 2, -1, 1]<br>depth = 3<br>on_value = 5.0<br>off_value = 0.0<br>axis = -1 </p><p>#Then output is [4 x 3]:<br>output =<br>[5.0 0.0 0.0] // one_hot(0)<br>[0.0 0.0 5.0] // one_hot(2)<br>[0.0 0.0 0.0] // one_hot(-1)<br>[0.0 5.0 0.0] // one_hot(1)<br>矩阵相关运算<br>操作    描述<br>tf.diag(diagonal, name=None)    返回一个给定对角值的对角tensor</p><h1 id="‘diagonal’-is-1-2-3-4"><a href="#‘diagonal’-is-1-2-3-4" class="headerlink" title="‘diagonal’ is [1, 2, 3, 4]"></a>‘diagonal’ is [1, 2, 3, 4]</h1><p>tf.diag(diagonal) ==&gt;<br>[[1, 0, 0, 0]<br>[0, 2, 0, 0]<br>[0, 0, 3, 0]<br>[0, 0, 0, 4]]<br>tf.diag_part(input, name=None)    功能与上面相反<br>tf.trace(x, name=None)    求一个2维tensor足迹，即对角值diagonal之和<br>tf.transpose(a, perm=None, name=’transpose’)    调换tensor的维度顺序<br>按照列表perm的维度排列调换tensor顺序，<br>如为定义，则perm为(n-1…0)</p><h1 id="‘x’-is-1-2-3-4-5-6-1"><a href="#‘x’-is-1-2-3-4-5-6-1" class="headerlink" title="‘x’ is [[1 2 3],[4 5 6]]"></a>‘x’ is [[1 2 3],[4 5 6]]</h1><p>tf.transpose(x) ==&gt; [[1 4], [2 5],[3 6]]</p><h1 id="Equivalently-1"><a href="#Equivalently-1" class="headerlink" title="Equivalently"></a>Equivalently</h1><p>tf.transpose(x, perm=[1, 0]) ==&gt; [[1 4],[2 5], [3 6]]<br>tf.matmul(a, b, transpose_a=False,<br>transpose_b=False, a_is_sparse=False,<br>b_is_sparse=False, name=None)    矩阵相乘<br>tf.matrix_determinant(input, name=None)    返回方阵的行列式<br>tf.matrix_inverse(input, adjoint=None, name=None)    求方阵的逆矩阵，adjoint为True时，计算输入共轭矩阵的逆矩阵<br>tf.cholesky(input, name=None)    对输入方阵cholesky分解，<br>即把一个对称正定的矩阵表示成一个下三角矩阵L和其转置的乘积的分解A=LL^T<br>tf.matrix_solve(matrix, rhs, adjoint=None, name=None)    求解tf.matrix_solve(matrix, rhs, adjoint=None, name=None)<br>matrix为方阵shape为[M,M],rhs的shape为[M,K]，output为[M,K]<br>复数操作<br>操作    描述<br>tf.complex(real, imag, name=None)    将两实数转换为复数形式</p><h1 id="tensor-‘real’-is-2-25-3-25"><a href="#tensor-‘real’-is-2-25-3-25" class="headerlink" title="tensor ‘real’ is [2.25, 3.25]"></a>tensor ‘real’ is [2.25, 3.25]</h1><h1 id="tensor-imag-is-4-75-5-75"><a href="#tensor-imag-is-4-75-5-75" class="headerlink" title="tensor imag is [4.75, 5.75]"></a>tensor imag is [4.75, 5.75]</h1><p>tf.complex(real, imag) ==&gt; [[2.25 + 4.75j], [3.25 + 5.75j]]<br>tf.complex_abs(x, name=None)    计算复数的绝对值，即长度。</p><h1 id="tensor-‘x’-is-2-25-4-75j-3-25-5-75j"><a href="#tensor-‘x’-is-2-25-4-75j-3-25-5-75j" class="headerlink" title="tensor ‘x’ is [[-2.25 + 4.75j], [-3.25 + 5.75j]]"></a>tensor ‘x’ is [[-2.25 + 4.75j], [-3.25 + 5.75j]]</h1><p>tf.complex_abs(x) ==&gt; [5.25594902, 6.60492229]<br>tf.conj(input, name=None)    计算共轭复数<br>tf.imag(input, name=None)<br>tf.real(input, name=None)    提取复数的虚部和实部<br>tf.fft(input, name=None)    计算一维的离散傅里叶变换，输入数据类型为complex64<br>归约计算(Reduction)<br>操作    描述<br>tf.reduce_sum(input_tensor, reduction_indices=None,<br>keep_dims=False, name=None)    计算输入tensor元素的和，或者安照reduction_indices指定的轴进行求和</p><h1 id="‘x’-is-1-1-1"><a href="#‘x’-is-1-1-1" class="headerlink" title="‘x’ is [[1, 1, 1]"></a>‘x’ is [[1, 1, 1]</h1><h1 id="1-1-1"><a href="#1-1-1" class="headerlink" title="[1, 1, 1]]"></a>[1, 1, 1]]</h1><p>tf.reduce_sum(x) ==&gt; 6<br>tf.reduce_sum(x, 0) ==&gt; [2, 2, 2]<br>tf.reduce_sum(x, 1) ==&gt; [3, 3]<br>tf.reduce_sum(x, 1, keep_dims=True) ==&gt; [[3], [3]]<br>tf.reduce_sum(x, [0, 1]) ==&gt; 6<br>tf.reduce_prod(input_tensor,<br>reduction_indices=None,<br>keep_dims=False, name=None)    计算输入tensor元素的乘积，或者安照reduction_indices指定的轴进行求乘积<br>tf.reduce_min(input_tensor,<br>reduction_indices=None,<br>keep_dims=False, name=None)    求tensor中最小值<br>tf.reduce_max(input_tensor,<br>reduction_indices=None,<br>keep_dims=False, name=None)    求tensor中最大值<br>tf.reduce_mean(input_tensor,<br>reduction_indices=None,<br>keep_dims=False, name=None)    求tensor中平均值<br>tf.reduce_all(input_tensor,<br>reduction_indices=None,<br>keep_dims=False, name=None)    对tensor中各个元素求逻辑’与’</p><h1 id="‘x’-is"><a href="#‘x’-is" class="headerlink" title="‘x’ is"></a>‘x’ is</h1><h1 id="True-True"><a href="#True-True" class="headerlink" title="[[True, True]"></a>[[True, True]</h1><h1 id="False-False"><a href="#False-False" class="headerlink" title="[False, False]]"></a>[False, False]]</h1><p>tf.reduce_all(x) ==&gt; False<br>tf.reduce_all(x, 0) ==&gt; [False, False]<br>tf.reduce_all(x, 1) ==&gt; [True, False]<br>tf.reduce_any(input_tensor,<br>reduction_indices=None,<br>keep_dims=False, name=None)    对tensor中各个元素求逻辑’或’<br>tf.accumulate_n(inputs, shape=None,<br>tensor_dtype=None, name=None)    计算一系列tensor的和</p><h1 id="tensor-‘a’-is-1-2-3-4"><a href="#tensor-‘a’-is-1-2-3-4" class="headerlink" title="tensor ‘a’ is [[1, 2], [3, 4]]"></a>tensor ‘a’ is [[1, 2], [3, 4]]</h1><h1 id="tensor-b-is-5-0-0-6"><a href="#tensor-b-is-5-0-0-6" class="headerlink" title="tensor b is [[5, 0], [0, 6]]"></a>tensor b is [[5, 0], [0, 6]]</h1><p>tf.accumulate_n([a, b, a]) ==&gt; [[7, 4], [6, 14]]<br>tf.cumsum(x, axis=0, exclusive=False,<br>reverse=False, name=None)    求累积和<br>tf.cumsum([a, b, c]) ==&gt; [a, a + b, a + b + c]<br>tf.cumsum([a, b, c], exclusive=True) ==&gt; [0, a, a + b]<br>tf.cumsum([a, b, c], reverse=True) ==&gt; [a + b + c, b + c, c]<br>tf.cumsum([a, b, c], exclusive=True, reverse=True) ==&gt; [b + c, c, 0]</p><p>分割(Segmentation)<br>操作    描述<br>tf.segment_sum(data, segment_ids, name=None)    根据segment_ids的分段计算各个片段的和<br>其中segment_ids为一个size与data第一维相同的tensor<br>其中id为int型数据，最大id不大于size<br>c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])<br>tf.segment_sum(c, tf.constant([0, 0, 1]))<br>==&gt;[[0 0 0 0]<br>[5 6 7 8]]<br>上面例子分为[0,1]两id,对相同id的data相应数据进行求和,<br>并放入结果的相应id中，<br>且segment_ids只升不降<br>tf.segment_prod(data, segment_ids, name=None)    根据segment_ids的分段计算各个片段的积<br>tf.segment_min(data, segment_ids, name=None)    根据segment_ids的分段计算各个片段的最小值<br>tf.segment_max(data, segment_ids, name=None)    根据segment_ids的分段计算各个片段的最大值<br>tf.segment_mean(data, segment_ids, name=None)    根据segment_ids的分段计算各个片段的平均值<br>tf.unsorted_segment_sum(data, segment_ids,<br>num_segments, name=None)    与tf.segment_sum函数类似，<br>不同在于segment_ids中id顺序可以是无序的<br>tf.sparse_segment_sum(data, indices,<br>segment_ids, name=None)    输入进行稀疏分割求和<br>c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])</p><h1 id="Select-two-rows-one-segment"><a href="#Select-two-rows-one-segment" class="headerlink" title="Select two rows, one segment."></a>Select two rows, one segment.</h1><p>tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))<br>==&gt; [[0 0 0 0]]<br>对原data的indices为[0,1]位置的进行分割，<br>并按照segment_ids的分组进行求和<br>序列比较与索引提取(Sequence Comparison and Indexing)<br>操作    描述<br>tf.argmin(input, dimension, name=None)    返回input最小值的索引index<br>tf.argmax(input, dimension, name=None)    返回input最大值的索引index<br>tf.listdiff(x, y, name=None)    返回x，y中不同值的索引<br>tf.where(input, name=None)    返回bool型tensor中为True的位置</p><h1 id="‘input’-tensor-is"><a href="#‘input’-tensor-is" class="headerlink" title="‘input’ tensor is"></a>‘input’ tensor is</h1><p>#[[True, False]</p><p>#[True, False]]</p><h1 id="‘input’-有两个’True’-那么输出两个坐标值"><a href="#‘input’-有两个’True’-那么输出两个坐标值" class="headerlink" title="‘input’ 有两个’True’,那么输出两个坐标值."></a>‘input’ 有两个’True’,那么输出两个坐标值.</h1><h1 id="‘input’的rank为2-所以每个坐标为具有两个维度"><a href="#‘input’的rank为2-所以每个坐标为具有两个维度" class="headerlink" title="‘input’的rank为2, 所以每个坐标为具有两个维度."></a>‘input’的rank为2, 所以每个坐标为具有两个维度.</h1><p>where(input) ==&gt;<br>[[0, 0],<br>[1, 0]]<br>tf.unique(x, name=None)    返回一个元组tuple(y,idx)，y为x的列表的唯一化数据列表，<br>idx为x数据对应y元素的index</p><h1 id="tensor-‘x’-is-1-1-2-4-4-4-7-8-8"><a href="#tensor-‘x’-is-1-1-2-4-4-4-7-8-8" class="headerlink" title="tensor ‘x’ is [1, 1, 2, 4, 4, 4, 7, 8, 8]"></a>tensor ‘x’ is [1, 1, 2, 4, 4, 4, 7, 8, 8]</h1><p>y, idx = unique(x)<br>y ==&gt; [1, 2, 4, 7, 8]<br>idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]<br>tf.invert_permutation(x, name=None)    置换x数据与索引的关系</p><h1 id="tensor-x-is-3-4-0-2-1"><a href="#tensor-x-is-3-4-0-2-1" class="headerlink" title="tensor x is [3, 4, 0, 2, 1]"></a>tensor x is [3, 4, 0, 2, 1]</h1><p>invert_permutation(x) ==&gt; [2, 4, 3, 0, 1]<br>神经网络(Neural Network)<br>激活函数（Activation Functions）<br>操作    描述<br>tf.nn.relu(features, name=None)    整流函数：max(features, 0)<br>tf.nn.relu6(features, name=None)    以6为阈值的整流函数：min(max(features, 0), 6)<br>tf.nn.elu(features, name=None)    elu函数，exp(features) - 1 if &lt; 0,否则features<br>Exponential Linear Units (ELUs)<br>tf.nn.softplus(features, name=None)    计算softplus：log(exp(features) + 1)<br>tf.nn.dropout(x, keep_prob,<br>noise_shape=None, seed=None, name=None)    计算dropout，keep_prob为keep概率<br>noise_shape为噪声的shape<br>tf.nn.bias_add(value, bias, data_format=None, name=None)    对value加一偏置量<br>此函数为tf.add的特殊情况，bias仅为一维，<br>函数通过广播机制进行与value求和,<br>数据格式可以与value不同，返回为与value相同格式<br>tf.sigmoid(x, name=None)    y = 1 / (1 + exp(-x))<br>tf.tanh(x, name=None)    双曲线切线激活函数<br>卷积函数（Convolution）<br>操作    描述<br>tf.nn.conv2d(input, filter, strides, padding,<br>use_cudnn_on_gpu=None, data_format=None, name=None)    在给定的4D input与 filter下计算2D卷积<br>输入shape为 [batch, height, width, in_channels]<br>tf.nn.conv3d(input, filter, strides, padding, name=None)    在给定的5D input与 filter下计算3D卷积<br>输入shape为[batch, in_depth, in_height, in_width, in_channels]<br>池化函数（Pooling）<br>操作    描述<br>tf.nn.avg_pool(value, ksize, strides, padding,<br>data_format=’NHWC’, name=None)    平均方式池化<br>tf.nn.max_pool(value, ksize, strides, padding,<br>data_format=’NHWC’, name=None)    最大值方法池化<br>tf.nn.max_pool_with_argmax(input, ksize, strides,<br>padding, Targmax=None, name=None)    返回一个二维元组(output,argmax),最大值pooling，返回最大值及其相应的索引<br>tf.nn.avg_pool3d(input, ksize, strides,<br>padding, name=None)    3D平均值pooling<br>tf.nn.max_pool3d(input, ksize, strides,<br>padding, name=None)    3D最大值pooling<br>数据标准化（Normalization）<br>操作    描述<br>tf.nn.l2_normalize(x, dim, epsilon=1e-12, name=None)    对维度dim进行L2范式标准化<br>output = x / sqrt(max(sum(x<strong>2), epsilon))<br>tf.nn.sufficient_statistics(x, axes, shift=None,<br>keep_dims=False, name=None)    计算与均值和方差有关的完全统计量<br>返回4维元组,<em>元素个数，</em>元素总和，<em>元素的平方和，</em>shift结果<br>参见算法介绍<br>tf.nn.normalize_moments(counts, mean_ss, variance_ss, shift, name=None)    基于完全统计量计算均值和方差<br>tf.nn.moments(x, axes, shift=None,<br>name=None, keep_dims=False)    直接计算均值与方差<br>损失函数（Losses）<br>操作    描述<br>tf.nn.l2_loss(t, name=None)    output = sum(t </strong> 2) / 2<br>分类函数（Classification）<br>操作    描述<br>tf.nn.sigmoid_cross_entropy_with_logits<br>(logits, targets, name=None)*    计算输入logits, targets的交叉熵<br>tf.nn.softmax(logits, name=None)    计算softmax<br>softmax[i, j] = exp(logits[i, j]) / sum_j(exp(logits[i, j]))<br>tf.nn.log_softmax(logits, name=None)    logsoftmax[i, j] = logits[i, j] - log(sum(exp(logits[i])))<br>tf.nn.softmax_cross_entropy_with_logits<br>(logits, labels, name=None)    计算logits和labels的softmax交叉熵<br>logits, labels必须为相同的shape与数据类型<br>tf.nn.sparse_softmax_cross_entropy_with_logits<br>(logits, labels, name=None)    计算logits和labels的softmax交叉熵<br>tf.nn.weighted_cross_entropy_with_logits<br>(logits, targets, pos_weight, name=None)    与sigmoid_cross_entropy_with_logits()相似，<br>但给正向样本损失加了权重pos_weight<br>符号嵌入（Embeddings）<br>操作    描述<br>tf.nn.embedding_lookup<br>(params, ids, partition_strategy=’mod’,<br>name=None, validate_indices=True)    根据索引ids查询embedding列表params中的tensor值<br>如果len(params) &gt; 1，id将会安照partition_strategy策略进行分割<br>1、如果partition_strategy为”mod”，<br>id所分配到的位置为p = id % len(params)<br>比如有13个ids，分为5个位置，那么分配方案为：<br>[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]<br>2、如果partition_strategy为”div”,那么分配方案为：<br>[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]<br>tf.nn.embedding_lookup_sparse(params,<br>sp_ids, sp_weights, partition_strategy=’mod’,<br>name=None, combiner=’mean’)    对给定的ids和权重查询embedding<br>1、sp_ids为一个N x M的稀疏tensor，<br>N为batch大小，M为任意，数据类型int64<br>2、sp_weights的shape与sp_ids的稀疏tensor权重，<br>浮点类型，若为None，则权重为全’1’<br>循环神经网络（Recurrent Neural Networks）<br>操作    描述<br>tf.nn.rnn(cell, inputs, initial_state=None, dtype=None,<br>sequence_length=None, scope=None)    基于RNNCell类的实例cell建立循环神经网络<br>tf.nn.dynamic_rnn(cell, inputs, sequence_length=None,<br>initial_state=None, dtype=None, parallel_iterations=None,<br>swap_memory=False, time_major=False, scope=None)    基于RNNCell类的实例cell建立动态循环神经网络<br>与一般rnn不同的是，该函数会根据输入动态展开<br>返回(outputs,state)<br>tf.nn.state_saving_rnn(cell, inputs, state_saver, state_name,<br>sequence_length=None, scope=None)    可储存调试状态的RNN网络<br>tf.nn.bidirectional_rnn(cell_fw, cell_bw, inputs,<br>initial_state_fw=None, initial_state_bw=None, dtype=None,<br>sequence_length=None, scope=None)    双向RNN, 返回一个3元组tuple<br>(outputs, output_state_fw, output_state_bw)<br>求值网络（Evaluation）<br>操作    描述<br>tf.nn.top_k(input, k=1, sorted=True, name=None)    返回前k大的值及其对应的索引<br>tf.nn.in_top_k(predictions, targets, k, name=None)    返回判断是否targets索引的predictions相应的值<br>是否在在predictions前k个位置中，<br>返回数据类型为bool类型，len与predictions同<br>监督候选采样网络（Candidate Sampling）<br>对于有巨大量的多分类与多标签模型，如果使用全连接softmax将会占用大量的时间与空间资源，所以采用候选采样方法仅使用一小部分类别与标签作为监督以加速训练。</p><p>操作    描述<br>Sampled Loss Functions<br>tf.nn.nce_loss(weights, biases, inputs, labels, num_sampled,<br>num_classes, num_true=1, sampled_values=None,<br>remove_accidental_hits=False, partition_strategy=’mod’,<br>name=’nce_loss’)    返回noise-contrastive的训练损失结果<br>tf.nn.sampled_softmax_loss(weights, biases, inputs, labels,<br>num_sampled, num_classes, num_true=1, sampled_values=None,<br>remove_accidental_hits=True, partition_strategy=’mod’,<br>name=’sampled_softmax_loss’)    返回sampled softmax的训练损失<br>参考- Jean et al., 2014第3部分<br>Candidate Samplers<br>tf.nn.uniform_candidate_sampler(true_classes, num_true,<br>num_sampled, unique, range_max, seed=None, name=None)    通过均匀分布的采样集合<br>返回三元tuple<br>1、sampled_candidates 候选集合。<br>2、期望的true_classes个数，为浮点值<br>3、期望的sampled_candidates个数，为浮点值<br>tf.nn.log_uniform_candidate_sampler(true_classes, num_true,<br>num_sampled, unique, range_max, seed=None, name=None)    通过log均匀分布的采样集合，返回三元tuple<br>tf.nn.learned_unigram_candidate_sampler<br>(true_classes, num_true, num_sampled, unique,<br>range_max, seed=None, name=None)    根据在训练过程中学习到的分布状况进行采样<br>返回三元tuple<br>tf.nn.fixed_unigram_candidate_sampler(true_classes, num_true,<br>num_sampled, unique, range_max, vocab_file=”,<br>distortion=1.0, num_reserved_ids=0, num_shards=1,<br>shard=0, unigrams=(), seed=None, name=None)    基于所提供的基本分布进行采样<br>保存与恢复变量<br>操作    描述<br>类tf.train.Saver(Saving and Restoring Variables)<br>tf.train.Saver.<strong>init</strong>(var_list=None, reshape=False,<br>sharded=False, max_to_keep=5,<br>keep_checkpoint_every_n_hours=10000.0,<br>name=None, restore_sequentially=False,<br>saver_def=None, builder=None)    创建一个存储器Saver<br>var_list定义需要存储和恢复的变量<br>tf.train.Saver.save(sess, save_path, global_step=None,<br>latest_filename=None, meta_graph_suffix=’meta’,<br>write_meta_graph=True)    保存变量<br>tf.train.Saver.restore(sess, save_path)    恢复变量<br>tf.train.Saver.last_checkpoints    列出最近未删除的checkpoint 文件名<br>tf.train.Saver.set_last_checkpoints(last_checkpoints)    设置checkpoint文件名列表<br>tf.train.Saver.set_last_checkpoints_with_time(last_checkpoints_with_time)    设置checkpoint文件名列表和时间戳</p>]]></content>
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> tensorflow操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>tensorflow中将label索引转换成one-hot形式</title>
      <link href="/2018/05/21/tensorflow%E4%B8%AD%E5%B0%86label%E7%B4%A2%E5%BC%95%E8%BD%AC%E6%8D%A2%E6%88%90one-hot%E5%BD%A2%E5%BC%8F/"/>
      <url>/2018/05/21/tensorflow%E4%B8%AD%E5%B0%86label%E7%B4%A2%E5%BC%95%E8%BD%AC%E6%8D%A2%E6%88%90one-hot%E5%BD%A2%E5%BC%8F/</url>
      <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">index=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">one_hot=tf.one_hot(a,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    print(sess.run(one_hot))</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418213841883?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjAzNDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="enter image description here"></p>]]></content>
      
      <categories>
          
          <category> python </category>
          
          <category> tensorflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> one_hot形式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中re模块使用，正则表达式</title>
      <link href="/2018/05/21/python%E4%B8%ADre%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/05/21/python%E4%B8%ADre%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正则表达式的基础知识就不说了,有兴趣的可以点击这里，提取一般分两种情况，一种是提取在文本中提取单个位置的字符串，另一种是提取连续多个位置的字符串。日志分析会遇到这种情况，下面我会分别讲一下对应的方法。</p><h2 id="一、单个位置的字符串提取"><a href="#一、单个位置的字符串提取" class="headerlink" title="一、单个位置的字符串提取"></a>一、单个位置的字符串提取</h2><p>这种情况我们可以使用(.+?)这个正则表达式来提取。 举例，一个字符串”a123b”,如果我们想提取ab之间的值123，可以使用findall配合正则表达式，这样会返回一个包含所以符合情况的list。</p><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str = <span class="string">"a123b"</span></span><br><span class="line"><span class="keyword">print</span> re.findall(<span class="string">r"a(.+?)b"</span>,str)<span class="comment">#</span></span><br><span class="line">输出[<span class="string">'123'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="1-1贪婪和非贪婪匹配"><a href="#1-1贪婪和非贪婪匹配" class="headerlink" title="1.1贪婪和非贪婪匹配"></a>1.1贪婪和非贪婪匹配</h3><p>如果我们有一个字符串”a123b456b”，如果我们想匹配a和最后一个b之间的所有值而非a和第一个出现的b之间的值，可以用?来控制正则贪婪和非贪婪匹配的情况。</p><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str = <span class="string">"a123b456b"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> re.findall(<span class="string">r"a(.+?)b"</span>, str)</span><br><span class="line"><span class="comment">#输出['123']#?控制只匹配0或1个,所以只会输出和最近的b之间的匹配情况</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> re.findall(<span class="string">r"a(.+)b"</span>, str)</span><br><span class="line"><span class="comment">#输出['123b456']</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> re.findall(<span class="string">r"a(.*)b"</span>, str)</span><br><span class="line"><span class="comment">#输出['123b456']</span></span><br></pre></td></tr></table></figure></p><h3 id="1-2多行匹配"><a href="#1-2多行匹配" class="headerlink" title="1.2多行匹配"></a>1.2多行匹配</h3><p>如果你要多行匹配，那么需要加上re.S和re.M标志. 加上re.S后。将会匹配换行符，默认.不会匹配换行符。<br>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"a23b\na34b"</span></span><br><span class="line"> </span><br><span class="line">re.findall(<span class="string">r"a(\d+)b.+a(\d+)b"</span>, str)</span><br><span class="line"><span class="comment">#输出[]</span></span><br><span class="line"><span class="comment">#因为不能处理str中间有\n换行的情况</span></span><br><span class="line"> </span><br><span class="line">re.findall(<span class="string">r"a(\d+)b.+a(\d+)b"</span>, str, re.S)</span><br><span class="line"><span class="comment">#s输出[('23', '34')]</span></span><br></pre></td></tr></table></figure></p><p>加上re.M后,^$标志将会匹配每一行，默认^和$只会匹配第一行。</p><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"a23b\na34b"</span></span><br><span class="line"> </span><br><span class="line">re.findall(<span class="string">r"^a(\d+)b"</span>, str)</span><br><span class="line"><span class="comment">#输出['23']</span></span><br><span class="line"> </span><br><span class="line">re.findall(<span class="string">r"^a(\d+)b"</span>, str, re.M)</span><br><span class="line"><span class="comment">#输出['23', '34']</span></span><br></pre></td></tr></table></figure></p><h2 id="二、连续多个位置的字符串提取"><a href="#二、连续多个位置的字符串提取" class="headerlink" title="二、连续多个位置的字符串提取"></a>二、连续多个位置的字符串提取</h2><p>这种情况我们可以使用(?P<name>…)这个正则表达式来提取。举例，如果我们有一行webserver的access日志:’192.168.0.1 25/Oct/2012:14:46:34 “GET /api HTTP/1.1” 200 44 “<a href="http://abc.com/search&quot;" target="_blank" rel="noopener">http://abc.com/search&quot;</a> “Mozilla/5.0”‘，我们想提取这行日志里面所有的内容，可以写多个(?P<name>expr)来提取,其中name可以更改为你为该位置字符串命名的变量，expr改成提取位置的正则即可。</name></name></p><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">line =<span class="string">'192.168.0.1 25/Oct/2012:14:46:34 "GET /api HTTP/1.1" 200 44 "http://abc.com/search"</span></span><br><span class="line"><span class="string">"Mozilla/5.0"'</span></span><br><span class="line">reg = re.compile(<span class="string">'^(?P&lt;remote_ip&gt;[^ ]*) (?P&lt;date&gt;[^ ]*) "(?P&lt;request&gt;[^"]*)"</span></span><br><span class="line"><span class="string">(?P&lt;status&gt;[^ ]*) (?P&lt;size&gt;[^ ]*) "(?P&lt;referrer&gt;[^"]*)" "(?P&lt;user_agent&gt;[^"]*)"'</span>)</span><br><span class="line">regMatch = reg.match(line)</span><br><span class="line">linebits = regMatch.groupdict()</span><br><span class="line"><span class="keyword">print</span> linebits</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> linebits.items() :</span><br><span class="line"> <span class="keyword">print</span> k+<span class="string">": "</span>+v</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re模块 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python数据处理——Pandas模块使用（二）</title>
      <link href="/2018/05/21/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E2%80%94%E2%80%94Pandas%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/05/21/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E2%80%94%E2%80%94Pandas%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="数据变换操作"><a href="#数据变换操作" class="headerlink" title="数据变换操作"></a>数据变换操作</h2><p><strong>导入文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">odata = pd.read_csv(&apos;example.csv&apos;)</span><br></pre></td></tr></table></figure></p><p>这三行代码就可以实现csv文件的导入，注意文件的路径</p><p><strong>删除行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data1 = data.drop([16,17])</span><br></pre></td></tr></table></figure></p><p><strong>drop()方法</strong></p><p>如果不设置参数inplace=True，则只能在生成的新数据块中实现删除效果，而不能删除原有数据块的相应行。也就是inplace属性可以对原来的数据进行删除操作Inplace = True用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odata.drop(odata.index[[16,17]],inplace=True)</span><br></pre></td></tr></table></figure><p>我们要注意到用与不用inplace的区别，不用inplace的时候，我们使用另外一个变量Data1来暂时保存处理后的数据，而使用inplace的时候，我们直接调用一个函数对原来的数据进行操作。值得注意的是，inplace属性并不会修改原来的文件，所以是安全的。也就是虽然直接对原来数据删除，但并不会删除到文件，只会在内存里操作原来变量。<br>删除列del data[‘date’]<br>代码如上所示，直接删除，注意这个del的方括号里只能够有一个参数。一次只能删除一列。</p><p><strong>pop()方法</strong></p><p>pop方法可以将所选列从原数据块中弹出，原数据块不再保留该列，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data1=data.pop(‘latitude’)</span><br></pre></td></tr></table></figure><p>pop方法将单独的数据取出来，在我们想要对某一块数据很感兴趣的时候非常实用。</p><p><strong>split()的使用</strong></p><p>简单的Python的字符串分割我们在数据预处理的时候很多时候要对一串带有各种符号的数据进行处理。但是实际运行时我们要将它们分开处理，所以需要用到python带的split函数来处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str = (&apos;www.google.com&apos;)</span><br><span class="line">print (str)</span><br><span class="line">str_split = str.split(&apos;.&apos;)</span><br><span class="line">print (str_split)</span><br><span class="line"></span><br><span class="line"># 这样运行出来的结果是</span><br><span class="line"># www.google.com</span><br><span class="line"># [‘www’,‘google’,‘com’]</span><br></pre></td></tr></table></figure><p>如果我们想要设置分割的个数，就在split里面添加参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str_split = str.split(‘.’,1)</span><br><span class="line"># 这样得出的结果是：</span><br><span class="line"># www.google.com</span><br><span class="line"># [‘www’,’google.com’]</span><br></pre></td></tr></table></figure><p>也就是只分割了第一个字符，第二个就没有分割了。</p><h2 id="数据框合并concat-操作"><a href="#数据框合并concat-操作" class="headerlink" title="数据框合并concat()操作"></a>数据框合并concat()操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">concat函数是在pandas底下的方法，可以将数据根据不同的轴作简单的融合</span><br><span class="line">pd.concat(objs, axis=0, join=&apos;outer&apos;, join_axes=None, ignore_index=False,</span><br><span class="line">       keys=None, levels=None, names=None, verify_integrity=False)</span><br></pre></td></tr></table></figure><p>参数说明<br>objs: series，dataframe或者是panel构成的序列lsit<br>axis： 需要合并链接的轴，0是行，1是列<br>join：连接的方式 inner，或者outer</p><p><strong>相同字段的表首尾相接</strong></p><p><img src="https://img-blog.csdn.net/20160913192849769" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 现将表构成list，然后在作为concat的输入</span><br><span class="line">In [4]: frames = [df1, df2, df3]</span><br><span class="line"></span><br><span class="line">In [5]: result = pd.concat(frames)</span><br></pre></td></tr></table></figure><p>要在相接的时候在加上一个层次的key来识别数据源自于哪张表，可以增加key参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.concat(frames, keys=[&apos;x&apos;, &apos;y&apos;, &apos;z&apos;])</span><br></pre></td></tr></table></figure><p>效果如下<br><img src="https://img-blog.csdn.net/20160913194106249" alt="这里写图片描述"></p><p><strong>横向表拼接（行对齐）</strong></p><p>当axis = 1的时候，concat就是行对齐，然后将不同列名称的两张表合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.concat([df1, df4], axis=1)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160913194820155" alt="这里写图片描述"></p><p><strong>join</strong></p><p>加上join参数的属性，如果为’inner’得到的是两表的交集，如果是outer，得到的是两表的并集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.concat([df1, df4], axis=1, join=&apos;inner&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160913195018721" alt="这里写图片描述"></p><p> <strong>join_axes</strong></p><p>如果有join_axes的参数传入，可以指定根据那个轴来对齐数据<br>例如根据df1表对齐数据，就会保留指定的df1表的轴，然后将df4的表与之拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.concat([df1, df4], axis=1, join_axes=[df1.index])</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160913195355535" alt="这里写图片描述"></p><p><strong>append</strong></p><p>append是series和dataframe的方法，使用它就是默认沿着列进行凭借（axis = 0，列对齐）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = df1.append(df2)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160913195644364" alt="这里写图片描述"></p><p><strong>无视index的concat</strong></p><p>如果两个表的index都没有实际含义，使用ignore_index参数，置true，合并的两个表就睡根据列字段对齐，然后合并。最后再重新整理一个新的index。<br><img src="https://img-blog.csdn.net/20160913200428629" alt="这里写图片描述"></p><p><strong>合并的同时增加区分数据组的键</strong></p><p>前面提到的keys参数可以用来给合并后的表增加key来区分不同的表数据来源</p><ol><li>直接用key参数实现</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.concat(frames, keys=[&apos;x&apos;, &apos;y&apos;, &apos;z&apos;])</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160913201130231" alt="这里写图片描述"></p><ol start="2"><li>传入字典来增加分组键</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pieces = &#123;&apos;x&apos;: df1, &apos;y&apos;: df2, &apos;z&apos;: df3&#125;</span><br><span class="line">result = pd.concat(pieces)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160913201130231" alt="这里写图片描述"></p><p><strong>在dataframe中加入新的行</strong></p><p>append方法可以将 series 和 字典就够的数据作为dataframe的新一行插入。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s2 = pd.Series([&apos;X0&apos;, &apos;X1&apos;, &apos;X2&apos;, &apos;X3&apos;], index=[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;])</span><br><span class="line">result = df1.append(s2, ignore_index=True)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160914090542084" alt="这里写图片描述"></p><p><strong>表格列字段不同的表合并</strong></p><p>如果遇到两张表的列字段本来就不一样，但又想将两个表合并，其中无效的值用nan来表示。那么可以使用ignore_index来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dicts = [&#123;&apos;A&apos;: 1, &apos;B&apos;: 2, &apos;C&apos;: 3, &apos;X&apos;: 4&#125;,&#123;&apos;A&apos;: 5, &apos;B&apos;: 6, &apos;C&apos;: 7, &apos;Y&apos;: 8&#125;]</span><br><span class="line">result = df1.append(dicts, ignore_index=True)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160914091035307" alt="这里写代码片"></p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
            <tag> pandas学习 </tag>
            
            <tag> 数据框操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>已解决：用anaconda安装最新的TensorFlow版本</title>
      <link href="/2018/05/21/%E5%B7%B2%E8%A7%A3%E5%86%B3%EF%BC%9A%E7%94%A8anaconda%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%9A%84TensorFlow%E7%89%88%E6%9C%AC/"/>
      <url>/2018/05/21/%E5%B7%B2%E8%A7%A3%E5%86%B3%EF%BC%9A%E7%94%A8anaconda%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%9A%84TensorFlow%E7%89%88%E6%9C%AC/</url>
      <content type="html"><![CDATA[<h1 id="用anaconda安装最新的TensorFlow版本"><a href="#用anaconda安装最新的TensorFlow版本" class="headerlink" title="用anaconda安装最新的TensorFlow版本"></a>用anaconda安装最新的TensorFlow版本</h1><h2 id="存在问题："><a href="#存在问题：" class="headerlink" title="存在问题："></a>存在问题：</h2><p>一般从anaconda官网下载的anaconda，查看tensorflow依然还是1.2的版本，现在用conda更新TensorFlow</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>1，打开anaconda-prompt</p><p>2，查看tensorflow各个版本：（查看会发现有一大堆TensorFlow源，但是不能随便选，选择可以用查找命令定位）</p><p>anaconda search -t conda tensorflow<br>4，找到自己安装环境对应的最新TensorFlow后（可以在终端搜索anaconda，定位到那一行），然后查看安装命令</p><p>anaconda show &lt;USER/PACKAGE&gt;<br>安装anaconda/tensorflow具体操作命令：</p><p>anaconda show anaconda/tensorflow<br>5，第4步会提供一个下载地址，使用下面命令就可安装新版本tensorflow</p><p>conda install –channel <a href="https://conda.anaconda.org/anaconda" target="_blank" rel="noopener">https://conda.anaconda.org/anaconda</a> tensorflow</p>]]></content>
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python数据处理——Pandas模块使用（一）</title>
      <link href="/2018/05/20/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E2%80%94%E2%80%94Pandas%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/05/20/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E2%80%94%E2%80%94Pandas%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="一、Pandas介绍"><a href="#一、Pandas介绍" class="headerlink" title="一、Pandas介绍"></a>一、Pandas介绍</h2><p>在处理实际的金融数据时，一个条数据通常包含了多种类型的数据，例如，股票的代码是字符串，收盘价是浮点型，而成交量是整型等。在C++中可以实现为一个给定结构体作为单元的容器，如向量（vector，C++中的特定数据结构）。在Python中，pandas包含了高级的数据结构Series和DataFrame，使得在Python中处理数据变得非常方便、快速和简单。pandas不同的版本之间存在一些不兼容性，为此，我们需要清楚使用的是哪一个版本的pandas。</p><h2 id="二、Pandas数据结构介绍"><a href="#二、Pandas数据结构介绍" class="headerlink" title="二、Pandas数据结构介绍"></a>二、Pandas数据结构介绍</h2><p>在pandas中有两类非常重要的数据结构，即序列Series和数据框DataFrame。Series类似于numpy中的一维数组，除了通吃一维数组可用的函数或方法，而且其可通过索引标签的方式获取数据，还具有索引的自动对齐功能；DataFrame类似于numpy中的二维数组，同样可以通用numpy数组的函数和方法，而且还具有其他灵活应用，后续会介绍到。</p><h3 id="1、Series的创建"><a href="#1、Series的创建" class="headerlink" title="1、Series的创建"></a>1、Series的创建</h3><p>Series的创建主要有三种方式：</p><p>1）通过一维数组创建序列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">arr1 = np.arange(<span class="number">5</span>)</span><br><span class="line">print(arr1)</span><br><span class="line">print(type(arr1))</span><br><span class="line">s1 = pd.Series(arr1)</span><br><span class="line">print(s1)</span><br><span class="line">print(type(s1))</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20180507194213523?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjAzNDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="运行结果"><br>2）通过字典的方式创建序列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">arr1 = &#123;<span class="string">'a'</span>:<span class="number">10</span>,<span class="string">'b'</span>:<span class="number">20</span>,<span class="string">'c'</span>:<span class="number">30</span>,<span class="string">'d'</span>:<span class="number">40</span>,<span class="string">'e'</span>:<span class="number">50</span>&#125;</span><br><span class="line">print(arr1)</span><br><span class="line">print(type(arr1))</span><br><span class="line">s1 = pd.Series(arr1)</span><br><span class="line">print(s1)</span><br><span class="line">print(type(s1))</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20180507194528949?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjAzNDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="运行结果"><br>3）通过DataFrame中的某一行或某一列创建序列，具体见DataFrame创建。</p><h3 id="2、DataFrame的创建"><a href="#2、DataFrame的创建" class="headerlink" title="2、DataFrame的创建"></a>2、DataFrame的创建</h3><p>数据框的创建主要有三种方式：</p><p>1）通过二维数组创建数据框</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">arr1 = np.array(np.arange(<span class="number">12</span>)).reshape(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">print(arr1)</span><br><span class="line">print(type(arr1))</span><br><span class="line">df1 = pd.DataFrame(arr1)</span><br><span class="line">print(df1)</span><br><span class="line">print(type(df1))</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180507194926432?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjAzNDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>2）通过字典的方式创建数据框<br>以下以两种字典来创建数据框，一个是字典列表，一个是嵌套字典。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dic1 = &#123;<span class="string">'a'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">'b'</span>: [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">        <span class="string">'c'</span>: [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>], <span class="string">'d'</span>: [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]&#125;</span><br><span class="line">print(dic1)</span><br><span class="line">print(type(dic1))</span><br><span class="line">df1 = pd.DataFrame(dic1)</span><br><span class="line">print(df1)</span><br><span class="line">print(type(df1))</span><br><span class="line"></span><br><span class="line">dic2 = &#123;<span class="string">'one'</span>: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>&#125;,</span><br><span class="line">        <span class="string">'two'</span>: &#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">6</span>, <span class="string">'c'</span>: <span class="number">7</span>, <span class="string">'d'</span>: <span class="number">8</span>&#125;,</span><br><span class="line">        <span class="string">'three'</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>, <span class="string">'b'</span>: <span class="number">10</span>, <span class="string">'c'</span>: <span class="number">11</span>, <span class="string">'d'</span>: <span class="number">12</span>&#125;&#125;</span><br><span class="line">print(dic2)</span><br><span class="line">print(type(dic2))</span><br><span class="line">df2 = pd.DataFrame(dic2)</span><br><span class="line">print(df2)</span><br><span class="line">print(type(df2))</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20180507195512903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjAzNDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>3）通过数据框的方式创建数据框<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df3=df2[[<span class="string">'one'</span>,<span class="string">'three'</span>]]</span><br><span class="line">print(df3)</span><br><span class="line">print(type(df3))</span><br><span class="line">s3 = df3[<span class="string">'one'</span>]</span><br><span class="line">print(s3)</span><br><span class="line">print(type(s3))</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20180507195723401?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MjAzNDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="三、数据索引index"><a href="#三、数据索引index" class="headerlink" title="三、数据索引index"></a>三、数据索引index</h2><p>细致的朋友可能会发现一个现象，不论是序列也好，还是数据框也好，对象的最左边总有一个非原始数据对象，这个是什么呢？不错，就是我们接下来要介绍的索引。<br>在我看来，序列或数据框的索引有两大用处，一个是通过索引值或索引标签获取目标数据，另一个是通过索引，可以使序列或数据框的计算、操作实现自动化对齐，下面我们就来看看这两个功能的应用。</p><p>1、通过索引值或索引标签获取数据</p><p>如果不给序列一个指定的索引值，则序列自动生成一个从0开始的自增索引。可以通过index查看序列的索引：</p><p>s4.index<br>现在我们为序列设定一个自定义的索引值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s4 = pd.Series(np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>]))</span><br><span class="line">print(s4)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># 0    1</span></span><br><span class="line"><span class="comment"># 1    1</span></span><br><span class="line"><span class="comment"># 2    2</span></span><br><span class="line"><span class="comment"># 3    3</span></span><br><span class="line"><span class="comment"># 4    5</span></span><br><span class="line"><span class="comment"># 5    8</span></span><br><span class="line"><span class="comment"># dtype: int32</span></span><br></pre></td></tr></table></figure></p><p>序列有了索引，就可以通过索引值或索引标签进行数据的获取：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s4[<span class="number">3</span>]</span><br><span class="line">s4[<span class="string">'e'</span>]</span><br><span class="line">s4[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line">s4[[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>,<span class="string">'f'</span>]]</span><br><span class="line">s4[:<span class="number">4</span>]</span><br><span class="line">s4[<span class="string">'c'</span>:]</span><br><span class="line">s4[<span class="string">'b'</span>:<span class="string">'e'</span>]</span><br></pre></td></tr></table></figure></p><p>千万注意：如果通过索引标签获取数据的话，末端标签所对应的值是可以返回的！在一维数组中，就无法通过索引标签获取数据，这也是序列不同于一维数组的一个方面。</p><p>2、自动化对齐<br>如果有两个序列，需要对这两个序列进行算术运算，这时索引的存在就体现的它的价值了—自动化对齐.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">s5 = pd.Series(np.array([<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">55</span>,<span class="number">80</span>]),</span><br><span class="line">               index = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>])</span><br><span class="line">print(s5)</span><br><span class="line"><span class="comment"># a    10</span></span><br><span class="line"><span class="comment"># b    15</span></span><br><span class="line"><span class="comment"># c    20</span></span><br><span class="line"><span class="comment"># d    30</span></span><br><span class="line"><span class="comment"># e    55</span></span><br><span class="line"><span class="comment"># f    80</span></span><br><span class="line"><span class="comment"># dtype: int32</span></span><br><span class="line">s6 = pd.Series(np.array([<span class="number">12</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">16</span>]),</span><br><span class="line">               index = [<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'g'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>,<span class="string">'f'</span>])</span><br><span class="line">print(s6)</span><br><span class="line"><span class="comment"># a    12</span></span><br><span class="line"><span class="comment"># c    11</span></span><br><span class="line"><span class="comment"># g    13</span></span><br><span class="line"><span class="comment"># b    15</span></span><br><span class="line"><span class="comment"># d    14</span></span><br><span class="line"><span class="comment"># f    16</span></span><br><span class="line"><span class="comment"># dtype: int32</span></span><br><span class="line"></span><br><span class="line">print(s5 + s6)</span><br><span class="line"><span class="comment"># a    22.0</span></span><br><span class="line"><span class="comment"># b    30.0</span></span><br><span class="line"><span class="comment"># c    31.0</span></span><br><span class="line"><span class="comment"># d    44.0</span></span><br><span class="line"><span class="comment"># e     NaN</span></span><br><span class="line"><span class="comment"># f    96.0</span></span><br><span class="line"><span class="comment"># g     NaN</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br><span class="line"></span><br><span class="line">print(s5/s6)</span><br><span class="line"><span class="comment"># a    0.833333</span></span><br><span class="line"><span class="comment"># b    1.000000</span></span><br><span class="line"><span class="comment"># c    1.818182</span></span><br><span class="line"><span class="comment"># d    2.142857</span></span><br><span class="line"><span class="comment"># e         NaN</span></span><br><span class="line"><span class="comment"># f    5.000000</span></span><br><span class="line"><span class="comment"># g         NaN</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br></pre></td></tr></table></figure></p><p>由于s5中没有对应的g索引，s6中没有对应的e索引，所以数据的运算会产生两个缺失值NaN。注意，这里的算术结果就实现了两个序列索引的自动对齐，而非简单的将两个序列加总或相除。对于数据框的对齐，不仅仅是行索引的自动对齐，同时也会自动对齐列索引（变量名）</p><p>数据框中同样有索引，而且数据框是二维数组的推广，所以其不仅有行索引，而且还存在列索引，关于数据框中的索引相比于序列的应用要强大的多，这部分内容将放在数据查询中讲解。</p><h2 id="四、利用pandas查询数据"><a href="#四、利用pandas查询数据" class="headerlink" title="四、利用pandas查询数据"></a>四、利用pandas查询数据</h2><p>这里的查询数据相当于R语言里的subset功能，可以通过布尔索引有针对的选取原数据的子集、指定行、指定列等。我们先导入一个student数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">student = pd.io.parsers.read_csv(<span class="string">'C:\\Users\\admin\\Desktop\\student.csv'</span>)</span><br><span class="line"><span class="comment"># 查询数据的前5行或末尾5行</span></span><br><span class="line"></span><br><span class="line">student.head()</span><br><span class="line">student.tail()</span><br><span class="line"><span class="comment"># 查询指定的行</span></span><br><span class="line"></span><br><span class="line">student.ix[[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>]] <span class="comment">#这里的ix索引标签函数必须是中括号[]</span></span><br><span class="line"><span class="comment"># 查询指定的列</span></span><br><span class="line"></span><br><span class="line">student[[<span class="string">'Name'</span>,<span class="string">'Height'</span>,<span class="string">'Weight'</span>]].head()  <span class="comment">#如果多个列的话，必须使用双重中括号</span></span><br><span class="line"><span class="comment"># 也可以通过ix索引标签查询指定的列</span></span><br><span class="line"></span><br><span class="line">student.ix[:,[<span class="string">'Name'</span>,<span class="string">'Height'</span>,<span class="string">'Weight'</span>]].head()</span><br><span class="line"><span class="comment"># 查询指定的行和列</span></span><br><span class="line"></span><br><span class="line">student.ix[[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="string">'Name'</span>,<span class="string">'Height'</span>,<span class="string">'Weight'</span>]].head()</span><br><span class="line"><span class="comment"># 以上是从行或列的角度查询数据的子集，现在我们来看看如何通过布尔索引实现数据的子集查询。</span></span><br><span class="line"><span class="comment"># 查询所有女生的信息</span></span><br><span class="line"></span><br><span class="line">student[student[<span class="string">'Sex'</span>]==<span class="string">'F'</span>]</span><br><span class="line"><span class="comment"># 查询出所有12岁以上的女生信息</span></span><br><span class="line"></span><br><span class="line">student[(student[<span class="string">'Sex'</span>]==<span class="string">'F'</span>) &amp; (student[<span class="string">'Age'</span>]&gt;<span class="number">12</span>)]</span><br><span class="line">查询出所有<span class="number">12</span>岁以上的女生姓名、身高和体重</span><br><span class="line"></span><br><span class="line">student[(student[<span class="string">'Sex'</span>]==<span class="string">'F'</span>) &amp; (student[<span class="string">'Age'</span>]&gt;<span class="number">12</span>)][[<span class="string">'Name'</span>,<span class="string">'Height'</span>,<span class="string">'Weight'</span>]]</span><br></pre></td></tr></table></figure><p>上面的查询逻辑其实非常的简单，需要注意的是，如果是多个条件的查询，必须在&amp;（且）或者|（或）的两端条件用括号括起来。</p><h2 id="五、统计分析"><a href="#五、统计分析" class="headerlink" title="五、统计分析"></a>五、统计分析</h2><p>pandas模块为我们提供了非常多的描述性统计分析的指标函数，如总和、均值、最小值、最大值等，我们来具体看看这些函数：<br>首先随机生成三组数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1234</span>)</span><br><span class="line">d1 = pd.Series(<span class="number">2</span>*np.random.normal(size = <span class="number">100</span>)+<span class="number">3</span>)</span><br><span class="line">d2 = np.random.f(<span class="number">2</span>,<span class="number">4</span>,size = <span class="number">100</span>)</span><br><span class="line">d3 = np.random.randint(<span class="number">1</span>,<span class="number">100</span>,size = <span class="number">100</span>)</span><br><span class="line">d1.count()  <span class="comment">#非空元素计算</span></span><br><span class="line">d1.min()    <span class="comment">#最小值</span></span><br><span class="line">d1.max()    <span class="comment">#最大值</span></span><br><span class="line">d1.idxmin() <span class="comment">#最小值的位置，类似于R中的which.min函数</span></span><br><span class="line">d1.idxmax() <span class="comment">#最大值的位置，类似于R中的which.max函数</span></span><br><span class="line">d1.quantile(<span class="number">0.1</span>)    <span class="comment">#10%分位数</span></span><br><span class="line">d1.sum()    <span class="comment">#求和</span></span><br><span class="line">d1.mean()   <span class="comment">#均值</span></span><br><span class="line">d1.median() <span class="comment">#中位数</span></span><br><span class="line">d1.mode()   <span class="comment">#众数</span></span><br><span class="line">d1.var()    <span class="comment">#方差</span></span><br><span class="line">d1.std()    <span class="comment">#标准差</span></span><br><span class="line">d1.mad()    <span class="comment">#平均绝对偏差</span></span><br><span class="line">d1.skew()   <span class="comment">#偏度</span></span><br><span class="line">d1.kurt()   <span class="comment">#峰度</span></span><br><span class="line">d1.describe()   <span class="comment">#一次性输出多个描述性统计指标</span></span><br></pre></td></tr></table></figure></p><p>必须注意的是，descirbe方法只能针对序列或数据框，一维数组是没有这个方法的。<br>这里自定义一个函数，将这些统计描述指标全部汇总到一起:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stats</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pd.Series([x.count(),x.min(),x.idxmin(),</span><br><span class="line">               x.quantile(<span class="number">.25</span>),x.median(),</span><br><span class="line">               x.quantile(<span class="number">.75</span>),x.mean(),</span><br><span class="line">               x.max(),x.idxmax(),</span><br><span class="line">               x.mad(),x.var(),</span><br><span class="line">               x.std(),x.skew(),x.kurt()],</span><br><span class="line">              index = [<span class="string">'Count'</span>,<span class="string">'Min'</span>,<span class="string">'Whicn_Min'</span>,</span><br><span class="line">                       <span class="string">'Q1'</span>,<span class="string">'Median'</span>,<span class="string">'Q3'</span>,<span class="string">'Mean'</span>,</span><br><span class="line">                       <span class="string">'Max'</span>,<span class="string">'Which_Max'</span>,<span class="string">'Mad'</span>,</span><br><span class="line">                       <span class="string">'Var'</span>,<span class="string">'Std'</span>,<span class="string">'Skew'</span>,<span class="string">'Kurt'</span>])</span><br><span class="line">stats(d1)</span><br></pre></td></tr></table></figure><p>在实际的工作中，我们可能需要处理的是一系列的数值型数据框，如何将这个函数应用到数据框中的每一列呢？可以使用apply函数，这个非常类似于R中的apply的应用方法。<br>将之前创建的d1,d2,d3数据构建数据框:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.array([d1,d2,d3]).T,columns=[<span class="string">'x1'</span>,<span class="string">'x2'</span>,<span class="string">'x3'</span>])</span><br><span class="line">df.head()</span><br><span class="line">df.apply(stats)</span><br></pre></td></tr></table></figure><p>非常完美，就这样很简单的创建了数值型数据的统计性描述。如果是离散型数据呢？就不能用这个统计口径了，我们需要统计离散变量的观测数、唯一值个数、众数水平及个数。你只需要使用describe方法就可以实现这样的统计了。<br>student[‘Sex’].describe()</p><p>除以上的简单描述性统计之外，还提供了连续变量的相关系数（corr）和协方差矩阵（cov）的求解，这个跟R语言是一致的用法。<br>df.corr()</p><p>关于相关系数的计算可以调用pearson方法或kendell方法或spearman方法，默认使用pearson方法。<br>df.corr(‘spearman’)</p><p>如果只想关注某一个变量与其余变量的相关系数的话，可以使用corrwith,如下方只关心x1与其余变量的相关系数:<br>df.corrwith(df[‘x1’])</p><p>数值型变量间的协方差矩阵<br>df.cov()</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
            <tag> pandas学习 </tag>
            
            <tag> 数据框操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python实现回归模型</title>
      <link href="/2018/05/19/python%E5%AE%9E%E7%8E%B0%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/05/19/python%E5%AE%9E%E7%8E%B0%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="XGBoost回归模型实现"><a href="#XGBoost回归模型实现" class="headerlink" title="XGBoost回归模型实现"></a>XGBoost回归模型实现</h1><h2 id="XGBoost的优点"><a href="#XGBoost的优点" class="headerlink" title="XGBoost的优点"></a>XGBoost的优点</h2><h3 id="2-1-正则化"><a href="#2-1-正则化" class="headerlink" title="2.1 正则化"></a>2.1 正则化</h3><p>　　XGBoost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。</p><h3 id="2-2-并行处理"><a href="#2-2-并行处理" class="headerlink" title="2.2 并行处理"></a>2.2 并行处理</h3><p>　　XGBoost工具支持并行。Boosting不是一种串行的结构吗?怎么并行的？注意XGBoost的并行不是tree粒度的并行，XGBoost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。XGBoost的并行是在特征粒度上的。</p><p>　　我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），XGBoost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。</p><h3 id="2-3-灵活性"><a href="#2-3-灵活性" class="headerlink" title="2.3 灵活性"></a>2.3 灵活性</h3><p>　　XGBoost支持用户自定义目标函数和评估函数，只要目标函数二阶可导就行。</p><h3 id="2-4-缺失值处理"><a href="#2-4-缺失值处理" class="headerlink" title="2.4 缺失值处理"></a>2.4 缺失值处理</h3><p>　　对于特征的值有缺失的样本，xgboost可以自动学习出它的分裂方向</p><p>2.5 剪枝<br>　　XGBoost 先从顶到底建立所有可以建立的子树，再从底到顶反向进行剪枝。比起GBM，这样不容易陷入局部最优解。</p><p>2.6 内置交叉验证<br>　　XGBoost允许在每一轮boosting迭代中使用交叉验证。因此，可以方便地获得最优boosting迭代次数。而GBM使用网格搜索，只能检测有限个值。</p><h2 id="3-XGBoost详解"><a href="#3-XGBoost详解" class="headerlink" title="3. XGBoost详解"></a>3. XGBoost详解</h2><h3 id="3-1-数据格式"><a href="#3-1-数据格式" class="headerlink" title="3.1 数据格式"></a>3.1 数据格式</h3><p>XGBoost可以加载多种数据格式的训练数据：　　<br>libsvm 格式的文本数据；<br>Numpy 的二维数组；<br>XGBoost 的二进制的缓存文件。加载的数据存储在对象 DMatrix 中。</p><p>示例代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> plot_importance</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># read in the iris data</span></span><br><span class="line">iris = load_iris()</span><br><span class="line"></span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">1234565</span>)</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'booster'</span>: <span class="string">'gbtree'</span>,</span><br><span class="line">    <span class="string">'objective'</span>: <span class="string">'multi:softmax'</span>,</span><br><span class="line">    <span class="string">'num_class'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'gamma'</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">'max_depth'</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">'lambda'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'subsample'</span>: <span class="number">0.7</span>,</span><br><span class="line">    <span class="string">'colsample_bytree'</span>: <span class="number">0.7</span>,</span><br><span class="line">    <span class="string">'min_child_weight'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'silent'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'eta'</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">'seed'</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="string">'nthread'</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">'num_rounds'</span> : <span class="number">500</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plst = params.items()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dtrain = xgb.DMatrix(X_train, y_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = xgb.train(plst, dtrain)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对测试集进行预测</span></span><br><span class="line">dtest = xgb.DMatrix(X_test)</span><br><span class="line">ans = model.predict(dtest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">cnt1 = <span class="number">0</span></span><br><span class="line">cnt2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(y_test)):</span><br><span class="line">    <span class="keyword">if</span> ans[i] == y_test[i]:</span><br><span class="line">        cnt1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cnt2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Accuracy: %.2f %% "</span> % (<span class="number">100</span> * cnt1 / (cnt1 + cnt2)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示重要特征</span></span><br><span class="line">plot_importance(model)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xgboost </tag>
            
            <tag> 回归模型 </tag>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/19/hello-world/"/>
      <url>/2018/05/19/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> next主题 </tag>
            
            <tag> 博客建站 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
